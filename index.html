<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Drift City Online</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            z-index: 10;
            background: linear-gradient(90deg, rgba(0,0,0,0.85), transparent);
            padding: 14px 18px;
            border-left: 4px solid #ff0000;
            border-radius: 6px;
            pointer-events: none;
        }

        #hud-title {
            font-size: 24px;
            font-weight: 900;
            letter-spacing: 1px;
            color: #ffd500;
            text-shadow: 0 0 6px rgba(0,0,0,0.8);
        }

        .hud-line {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.85);
            text-align: right;
            font-size: 13px;
            background: rgba(0,0,0,0.6);
            padding: 10px 14px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0,0,0,0.6);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 22px;
            font-weight: bold;
            background: rgba(0,0,0,0.9);
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 200;
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
        }

        #minimap-frame {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 220px;
            height: 220px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 0 12px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 9;
            background: radial-gradient(circle at center, rgba(255,255,255,0.08), rgba(0,0,0,0.9));
        }

        #minimap-label {
            position: absolute;
            top: 18px;
            right: 24px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-shadow: 0 0 6px rgba(0,0,0,0.9);
            z-index: 11;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Lade CLS 63 Modell...</div>

    <div id="hud">
        <div id="hud-title">DRIFT CITY ONLINE</div>
        <div class="hud-line">Speed: <span id="speed-text">0</span> km/h</div>
    </div>

    <div id="minimap-frame"></div>
    <div id="minimap-label">MINIMAP</div>

    <div id="controls">
        <b>W</b> Gas &nbsp;|&nbsp; <b>S</b> Bremse / Rückwärts<br>
        <b>A / D</b> Lenken &nbsp;|&nbsp; <b>SPACE</b> Drift<br>
        <span style="font-size:11px; opacity:0.8;">R = Reset auf Startposition</span>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';

        // ==========================================
        // Einstellungen
        // ==========================================

        const CAR_FILE = 'mersedes_cls63.glb';

        const CAR_SCALE = 8.0;
        const CAR_LIFT = 1.2;
        const CAR_ROT_Y = 0;   // rad

        const CAR_COLOR = 0x111111;
        const TRACK_WIDTH = 22;
        const SKY_COLOR = 0x8fd3ff;

        // Physik
        let speed = 0;
        let maxSpeed = 1.9;
        let baseAcceleration = 0.016;
        let reverseSpeed = 0.7;
        let turnSpeed = 0.048;

        let currentDriftAngle = 0;
        let targetDriftAngle = 0;
        let driftSmoothness = 0.08;

        let keys = { w: false, a: false, s: false, d: false, space: false };

        // global
        let scene, camera, miniCamera, renderer;
        let playerGroup, carModel, loadedCarMesh;
        let tires = [], particles = [];
        let obstacles = [];

        const speedLabel = document.getElementById('speed-text');
        let lastTime = performance.now();

        init();
        requestAnimationFrame(animate);

        // ==========================================
        // Init
        // ==========================================

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(SKY_COLOR, 80, 1200);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                3000
            );

            miniCamera = new THREE.OrthographicCamera(-90, 90, 90, -90, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false;
            renderer.setClearColor(SKY_COLOR, 1);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.15);
            sun.position.set(300, 500, 300);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            sun.shadow.camera.left = -800;
            sun.shadow.camera.right = 800;
            sun.shadow.camera.top = 800;
            sun.shadow.camera.bottom = -800;
            scene.add(sun);

            createGround();
            createCityRoads();
            createBlocksAndBuildings();
            createCityPark();
            createBridgeHighway();
            createParkingGarage();
            createCar();

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // ==========================================
        // Environment – GTA-Style Downtown
        // ==========================================

        function createGround() {
            // Großflächige Stadtfläche (dunkelgrau)
            const baseGeo = new THREE.PlaneGeometry(4000, 4000);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x2b2f35, roughness: 0.95 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI / 2;
            base.position.y = -0.25;
            base.receiveShadow = true;
            scene.add(base);

            // etwas Rand-Grün an den Ecken (Vorstadt-Feeling)
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x2f7f3b, roughness: 1 });
            const cornerGeo = new THREE.PlaneGeometry(500, 500);
            const corners = [
                [-800, -800],
                [800, -800],
                [-800, 800],
                [800, 800]
            ];
            corners.forEach(([x, z]) => {
                const g = new THREE.Mesh(cornerGeo, grassMat);
                g.rotation.x = -Math.PI / 2;
                g.position.set(x, -0.24, z);
                g.receiveShadow = true;
                scene.add(g);
            });
        }

        function createCityRoads() {
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x25282f, roughness: 0.9 });
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xf7f7f7 });
            const sideLine = new THREE.MeshBasicMaterial({ color: 0xdddddd });

            const grid = [-300, -150, 0, 150, 300]; // Raster wie Kreuzungen in GTA

            // horizontale Straßen
            grid.forEach(z => {
                const road = new THREE.Mesh(
                    new THREE.BoxGeometry(900, 0.15, TRACK_WIDTH),
                    roadMat
                );
                road.position.set(0, -0.05, z);
                road.receiveShadow = true;
                scene.add(road);

                // Mittelstrich
                const lineGeo = new THREE.BoxGeometry(4, 0.17, 30);
                for (let x = -420; x <= 420; x += 60) {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.position.set(x, 0.02, z);
                    scene.add(line);
                }

                // Seitenlinien
                const borderGeo = new THREE.BoxGeometry(2, 0.18, 900);
                const leftB = new THREE.Mesh(borderGeo, sideLine);
                leftB.position.set(-TRACK_WIDTH / 2, 0.03, z);
                const rightB = leftB.clone();
                rightB.position.x = TRACK_WIDTH / 2;
                scene.add(leftB, rightB);
            });

            // vertikale Straßen
            grid.forEach(x => {
                const road = new THREE.Mesh(
                    new THREE.BoxGeometry(TRACK_WIDTH, 0.15, 900),
                    roadMat
                );
                road.position.set(x, -0.05, 0);
                road.receiveShadow = true;
                scene.add(road);

                // Mittelstrich
                const lineGeo = new THREE.BoxGeometry(4, 0.17, 30);
                for (let z = -420; z <= 420; z += 60) {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.rotation.y = Math.PI / 2;
                    line.position.set(x, 0.02, z);
                    scene.add(line);
                }

                // Seitenlinien
                const borderGeo = new THREE.BoxGeometry(2, 0.18, 900);
                const frontB = new THREE.Mesh(borderGeo, sideLine);
                frontB.rotation.y = Math.PI / 2;
                frontB.position.set(x, 0.03, -TRACK_WIDTH / 2);
                const backB = frontB.clone();
                backB.position.z = TRACK_WIDTH / 2;
                scene.add(frontB, backB);
            });

            // Zebrastreifen an zentraler Kreuzung
            createCrosswalk(0, 0);
        }

        function createCrosswalk(cx, cz) {
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const stripeGeo = new THREE.BoxGeometry(3, 0.18, 1.5);

            // quer über Nord-Süd Straße
            for (let i = -6; i <= 6; i++) {
                const s = new THREE.Mesh(stripeGeo, stripeMat);
                s.position.set(cx + i * 2.6, 0.04, cz + TRACK_WIDTH / 2 + 2);
                scene.add(s);
            }

            // quer über Ost-West Straße
            for (let i = -6; i <= 6; i++) {
                const s = new THREE.Mesh(stripeGeo, stripeMat);
                s.rotation.y = Math.PI / 2;
                s.position.set(cx - TRACK_WIDTH / 2 - 2, 0.04, cz + i * 2.6);
                scene.add(s);
            }
        }

        function createBlocksAndBuildings() {
            const buildingColors = [0x1f2933, 0x262f3d, 0x353f4f, 0x202833];

            function addBuildingBlock(centerX, centerZ, blockW, blockD, pattern) {
                // pattern: 'towers' | 'mid' | 'residential'
                const rows = 2;
                const cols = 2;
                const padding = 12;
                const cellW = (blockW - padding * 3) / cols;
                const cellD = (blockD - padding * 3) / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const bx = centerX - blockW / 2 + padding + cellW / 2 + c * (cellW + padding);
                        const bz = centerZ - blockD / 2 + padding + cellD / 2 + r * (cellD + padding);

                        let baseH;
                        if (pattern === 'towers') {
                            baseH = 80 + Math.random() * 60;
                        } else if (pattern === 'mid') {
                            baseH = 45 + Math.random() * 35;
                        } else {
                            baseH = 25 + Math.random() * 20;
                        }

                        const bodyMat = new THREE.MeshStandardMaterial({
                            color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                            roughness: 0.95,
                            metalness: 0.05
                        });

                        const body = new THREE.Mesh(
                            new THREE.BoxGeometry(cellW * 0.9, baseH, cellD * 0.9),
                            bodyMat
                        );
                        body.position.set(bx, baseH / 2, bz);
                        body.castShadow = true;
                        body.receiveShadow = true;

                        const roof = new THREE.Mesh(
                            new THREE.BoxGeometry(cellW * 0.92, 1.3, cellD * 0.92),
                            new THREE.MeshStandardMaterial({ color: 0x1b1b1b, roughness: 0.7 })
                        );
                        roof.position.set(bx, baseH + 0.6, bz);
                        roof.castShadow = true;

                        scene.add(body, roof);

                        const radius = Math.max(cellW, cellD) * 0.6;
                        obstacles.push({ pos: new THREE.Vector3(bx, 0, bz), radius });
                    }
                }
            }

            // Blöcke zwischen den Straßen (4x4 Blocks um Zentrum)
            const centers = [
                [-225, -225, 'towers'],    // Downtown-Skyscraper
                [0, -225, 'mid'],       // Büroblock
                [225, -225, 'residential'],

                [-225, 0, 'mid'],
                [225, 0, 'mid'],

                [-225, 225, 'residential'],
                [0, 225, 'mid'],
                [225, 225, 'residential']
            ];

            centers.forEach(([x, z, pattern]) => {
                addBuildingBlock(x, z, 120, 120, pattern);
            });
        }

        function createCityPark() {
            // Stadtpark nahe Zentrum
            const parkMat = new THREE.MeshStandardMaterial({ color: 0x3ba857, roughness: 0.9 });
            const pathMat = new THREE.MeshStandardMaterial({ color: 0xd3d3d3, roughness: 0.8 });

            const park = new THREE.Mesh(new THREE.BoxGeometry(160, 0.12, 140), parkMat);
            park.position.set(-225, -0.03, 60);
            park.receiveShadow = true;
            scene.add(park);

            // Wege
            const mainPath = new THREE.Mesh(new THREE.BoxGeometry(12, 0.14, 140), pathMat);
            mainPath.position.set(-225, 0.01, 60);
            scene.add(mainPath);

            const crossPath = new THREE.Mesh(new THREE.BoxGeometry(160, 0.14, 10), pathMat);
            crossPath.position.set(-225, 0.01, 60);
            scene.add(crossPath);

            // Bäume
            const trunkGeo = new THREE.CylinderGeometry(1, 1.3, 6, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5b3b1f });
            const leafGeo = new THREE.SphereGeometry(4.2, 8, 8);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x247b37 });

            for (let i = 0; i < 18; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 3;
                trunk.castShadow = true;
                const crown = new THREE.Mesh(leafGeo, leafMat);
                crown.position.y = 8;
                crown.castShadow = true;
                tree.add(trunk, crown);

                const rx = -225 - 65 + Math.random() * 130;
                const rz = 60 - 55 + Math.random() * 110;
                tree.position.set(rx, 0, rz);
                scene.add(tree);

                obstacles.push({ pos: new THREE.Vector3(rx, 0, rz), radius: 4.5 });
            }
        }

        function createBridgeHighway() {
            const group = new THREE.Group();

            const deckMat = new THREE.MeshStandardMaterial({ color: 0x3a3d44, roughness: 0.6 });
            const sideMat = new THREE.MeshStandardMaterial({ color: 0x22252e, roughness: 0.8 });

            // Elevated Highway diagonal über die City (wie GTA-Expressway)
            const length = 520;
            const deck = new THREE.Mesh(new THREE.BoxGeometry(length, 3, 18), deckMat);
            deck.position.set(0, 22, -260);
            deck.rotation.y = Math.PI / 6;
            deck.castShadow = true;
            deck.receiveShadow = true;
            group.add(deck);

            // Geländer
            const railGeo = new THREE.BoxGeometry(length, 1.2, 0.7);
            const railL = new THREE.Mesh(railGeo, sideMat);
            railL.position.set(0, 24, -260 - 9);
            railL.rotation.y = Math.PI / 6;

            const railR = railL.clone();
            railR.position.z = -260 + 9;
            group.add(railL, railR);

            // Pfeiler
            const pillarGeo = new THREE.BoxGeometry(4, 22, 4);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x4b4f59, roughness: 0.9 });

            for (let i = -2; i <= 2; i++) {
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                const t = i / 2;
                p.position.set(t * 260, 11, -260 + t * 80);
                p.castShadow = true;
                p.receiveShadow = true;
                group.add(p);

                obstacles.push({ pos: new THREE.Vector3(p.position.x, 0, p.position.z), radius: 6 });
            }

            scene.add(group);
        }

        function createParkingGarage() {
            const group = new THREE.Group();
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x4a4f5a, roughness: 0.8 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x2c3139, roughness: 0.9 });

            const floors = 3;
            const w = 80, d = 60, h = 3.5;
            for (let i = 0; i < floors; i++) {
                const y = i * h;

                const floor = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, d), floorMat);
                floor.position.set(0, y + 0.3, 0);
                floor.castShadow = true;
                floor.receiveShadow = true;
                group.add(floor);

                const wallFront = new THREE.Mesh(new THREE.BoxGeometry(w, 2.5, 0.6), wallMat);
                wallFront.position.set(0, y + 1.6, d / 2);
                const wallBack = wallFront.clone();
                wallBack.position.z = -d / 2;
                const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, d), wallMat);
                wallLeft.position.set(-w / 2, y + 1.6, 0);
                const wallRight = wallLeft.clone();
                wallRight.position.x = w / 2;
                [wallFront, wallBack, wallLeft, wallRight].forEach(wall => {
                    wall.castShadow = true;
                    group.add(wall);
                });
            }

            // optische Rampe
            const ramp = new THREE.Mesh(
                new THREE.BoxGeometry(20, 0.6, 40),
                floorMat
            );
            ramp.position.set(40, 1.5, -20);
            ramp.rotation.z = -0.4;
            ramp.castShadow = true;
            group.add(ramp);

            // Garage an markanter Ecke
            group.position.set(300, 0, 180);
            scene.add(group);

            obstacles.push({ pos: new THREE.Vector3(300, 0, 180), radius: 70 });
        }

        // ==========================================
        // Auto
        // ==========================================

        function createCar() {
            playerGroup = new THREE.Group();
            carModel = new THREE.Group();
            playerGroup.position.set(0, 0.5, 40);     // Start leicht über der zentralen Kreuzung
            playerGroup.rotation.y = Math.PI;        // Richtung "Innenstadt"
            playerGroup.add(carModel);
            scene.add(playerGroup);

            const loader = new GLTFLoader();
            loader.load(
                CAR_FILE,
                (gltf) => {
                    document.getElementById('loading').style.display = 'none';
                    loadedCarMesh = gltf.scene;

                    loadedCarMesh.scale.set(CAR_SCALE, CAR_SCALE, CAR_SCALE);
                    loadedCarMesh.position.y = CAR_LIFT;
                    loadedCarMesh.rotation.y = CAR_ROT_Y;

                    const paint = new THREE.MeshStandardMaterial({
                        color: CAR_COLOR,
                        metalness: 0.6,
                        roughness: 0.2
                    });

                    loadedCarMesh.traverse(child => {
                        if (child.isMesh) {
                            child.material = paint;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    carModel.add(loadedCarMesh);

                    const t1 = new THREE.Object3D();
                    t1.position.set(-1.5, 0, 1.5);
                    const t2 = new THREE.Object3D();
                    t2.position.set(1.5, 0, 1.5);
                    carModel.add(t1, t2);
                    tires.push(t1, t2);
                },
                undefined,
                (err) => {
                    console.error('Fehler beim Laden des Modells:', err);
                    document.getElementById('loading').innerText = 'Fehler beim Laden des Autos';
                }
            );
        }

        // ==========================================
        // Input
        // ==========================================

        function onKeyDown(e) {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = true;
            if (e.code === 'Space') keys.space = true;
            if (k === 'r') {
                playerGroup.position.set(0, 0.5, 40);
                playerGroup.rotation.set(0, Math.PI, 0);
                speed = 0;
            }
        }

        function onKeyUp(e) {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = false;
            if (e.code === 'Space') keys.space = false;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==========================================
        // Effekte
        // ==========================================

        function spawnSmoke(pos) {
            if (Math.random() > 0.4) return;
            const p = new THREE.Mesh(
                new THREE.BoxGeometry(0.35, 0.35, 0.35),
                new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.45 })
            );
            p.position.copy(pos);
            p.position.y = 0.25;
            p.rotation.set(Math.random(), Math.random(), Math.random());
            scene.add(p);
            particles.push({ mesh: p, life: 1.0 });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                p.mesh.position.y += 0.05;
                p.mesh.scale.multiplyScalar(1.04);
                p.mesh.material.opacity = p.life * 0.5;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // ==========================================
        // Main Loop
        // ==========================================

        function animate(now) {
            requestAnimationFrame(animate);
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            updatePhysics(delta);
            updateCamera();
            updateMiniMapCamera();
            updateParticles();

            const displaySpeed = Math.min(Math.floor(Math.abs(speed) * 150), 340);
            speedLabel.textContent = displaySpeed.toString();

            renderer.clear();
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
            renderer.render(scene, camera);

            const size = 220;
            const x = window.innerWidth - size - 20;
            renderer.setViewport(x, window.innerHeight - size - 20, size, size);
            renderer.setScissor(x, window.innerHeight - size - 20, size, size);
            renderer.setScissorTest(true);
            renderer.render(scene, miniCamera);
            renderer.setScissorTest(false);
        }

        // ==========================================
        // Physik & Kamera
        // ==========================================

        function updatePhysics(delta) {
            if (keys.w) {
                const speedFactor = 1 - (speed / maxSpeed);
                const currentAccel = baseAcceleration * (speedFactor > 0.15 ? speedFactor : 0.15);
                speed += currentAccel;
            } else if (keys.s) {
                speed -= baseAcceleration * 1.6;
            } else {
                speed *= 0.985;
            }

            if (speed > maxSpeed) speed = maxSpeed;
            if (speed < -reverseSpeed) speed = -reverseSpeed;

            if (Math.abs(speed) > 0.05) {
                const dir = speed > 0 ? 1 : -1;
                let dynamicTurn = turnSpeed * (1 - (speed / maxSpeed) * 0.3);
                if (keys.a) playerGroup.rotation.y += dynamicTurn * dir;
                if (keys.d) playerGroup.rotation.y -= dynamicTurn * dir;
            }

            playerGroup.translateZ(-speed);

            for (const o of obstacles) {
                const dist = new THREE.Vector2(
                    playerGroup.position.x - o.pos.x,
                    playerGroup.position.z - o.pos.z
                ).length();

                if (dist < o.radius) {
                    const push = new THREE.Vector3(
                        playerGroup.position.x - o.pos.x,
                        0,
                        playerGroup.position.z - o.pos.z
                    ).normalize().multiplyScalar(0.7);
                    playerGroup.position.add(push);
                    speed *= -0.3;
                }
            }

            targetDriftAngle = 0;
            if (keys.space && Math.abs(speed) > 0.6) {
                if (keys.a) targetDriftAngle = 0.55;
                else if (keys.d) targetDriftAngle = -0.55;

                tires.forEach(t => {
                    const p = new THREE.Vector3();
                    t.getWorldPosition(p);
                    spawnSmoke(p);
                });

                speed *= 0.99;
            }

            currentDriftAngle = THREE.MathUtils.lerp(currentDriftAngle, targetDriftAngle, driftSmoothness);
            carModel.rotation.y = currentDriftAngle;
        }

        function updateCamera() {
            const relativeCamOffset = new THREE.Vector3(0, 3.4, 8.8);
            const cameraOffset = relativeCamOffset.applyMatrix4(playerGroup.matrixWorld);
            camera.position.lerp(cameraOffset, 0.12);

            const lookAtTarget = new THREE.Vector3(0, 1.9, -6);
            lookAtTarget.applyMatrix4(playerGroup.matrixWorld);
            camera.lookAt(lookAtTarget);
        }

        function updateMiniMapCamera() {
            const target = playerGroup.position.clone();
            miniCamera.position.set(target.x, 130, target.z);
            miniCamera.lookAt(target);
            miniCamera.rotation.z = 0; // Nord nach oben
        }
    </script>
</body>
</html>

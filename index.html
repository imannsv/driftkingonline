<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <title>Drift King Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #111;
            font-family: system-ui, sans-serif;
        }

        #overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 14px;
            background: rgba(0,0,0,0.75);
            color: #fff;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
        }

            #overlay b {
                font-size: 15px;
            }
    </style>
</head>
<body>
    <div id="overlay">
        <b>Drift King Online</b><br>
        W / S = Gas / Bremse<br>
        A / D = Lenken<br>
        Space = Handbremse (Drift)
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
        window.onload = () => {

            // === Szene / Kamera / Renderer ===
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x9ad9ff);
            scene.fog = new THREE.Fog(0x9ad9ff, 80, 260);

            const camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, -12);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // === Licht ===
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(40, 60, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024);
            scene.add(sun);

            // === Boden / Track ===
            const groundGeo = new THREE.PlaneGeometry(400, 400);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x6b7684,
                roughness: 1,
                metalness: 0,
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const trackGeo = new THREE.PlaneGeometry(90, 160);
            const trackMat = new THREE.MeshStandardMaterial({
                color: 0x232530,
                roughness: 1,
                metalness: 0,
                flatShading: true
            });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.x = -Math.PI / 2;
            track.position.y = 0.02;
            scene.add(track);

            // Linien
            function createLine(width, height, x, z) {
                const geo = new THREE.PlaneGeometry(width, height);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 1,
                    metalness: 0,
                    flatShading: true,
                    side: THREE.DoubleSide
                });
                const line = new THREE.Mesh(geo, mat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.03, z);
                scene.add(line);
            }

            createLine(90, 1, 0, 78);
            createLine(90, 1, 0, -78);
            createLine(1, 160, 46, 0);
            createLine(1, 160, -46, 0);
            createLine(4, 40, 0, 0);

            // === Hintergrundblöcke (Anime City) ===
            const blockColors = [0xff9aa2, 0xffe29f, 0xbaffc9, 0xa0c4ff, 0xd4b5ff];
            const blockGeo = new THREE.BoxGeometry(12, 14, 12);
            for (let i = 0; i < 14; i++) {
                const m = new THREE.MeshStandardMaterial({
                    color: blockColors[i % blockColors.length],
                    roughness: 1,
                    metalness: 0,
                    flatShading: true
                });
                const b = new THREE.Mesh(blockGeo, m);
                b.castShadow = true;
                b.receiveShadow = true;
                const side = Math.random() > 0.5 ? 1 : -1;
                b.position.set(
                    side * (70 + Math.random() * 60),
                    7,
                    (Math.random() - 0.5) * 220
                );
                scene.add(b);
            }

            // === Auto (CLS-inspiriert) ===
            const car = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x101010,
                roughness: 0.85,
                metalness: 0.2,
                flatShading: true
            });

            // Hauptkarosserie
            const mainBody = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 0.7, 5.4),
                bodyMat
            );
            mainBody.position.y = 0.8;
            mainBody.castShadow = true;
            car.add(mainBody);

            // Motorhaube
            const hood = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.5, 1.8),
                bodyMat
            );
            hood.position.set(0, 0.75, 1.9);
            hood.castShadow = true;
            car.add(hood);

            // Heck
            const rear = new THREE.Mesh(
                new THREE.BoxGeometry(2.6, 0.6, 1.8),
                bodyMat
            );
            rear.position.set(0, 0.85, -2.0);
            rear.castShadow = true;
            car.add(rear);

            // Dach / Coupé-Linie
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.7, 2.6),
                new THREE.MeshStandardMaterial({
                    color: 0x151515,
                    roughness: 0.9,
                    metalness: 0.3,
                    flatShading: true
                })
            );
            roof.position.set(0, 1.3, -0.2);
            roof.castShadow = true;
            car.add(roof);

            // Fenster
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x8bbcff,
                roughness: 0.15,
                metalness: 0,
                flatShading: true
            });

            const sideGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.1, 0.6, 2.2),
                glassMat
            );
            sideGlass.position.set(0, 1.3, -0.2);
            car.add(sideGlass);

            const frontGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.0, 0.6, 0.12),
                glassMat
            );
            frontGlass.position.set(0, 1.2, 1.3);
            car.add(frontGlass);

            const rearGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.0, 0.5, 0.12),
                glassMat
            );
            rearGlass.position.set(0, 1.15, -2.0);
            car.add(rearGlass);

            // Frontstoßstange
            const frontBumper = new THREE.Mesh(
                new THREE.BoxGeometry(2.9, 0.4, 0.8),
                new THREE.MeshStandardMaterial({
                    color: 0x050505,
                    roughness: 1,
                    metalness: 0.1,
                    flatShading: true
                })
            );
            frontBumper.position.set(0, 0.5, 2.7);
            car.add(frontBumper);

            // Heckdiffusor
            const rearDiff = new THREE.Mesh(
                new THREE.BoxGeometry(2.6, 0.35, 0.9),
                new THREE.MeshStandardMaterial({
                    color: 0x050505,
                    roughness: 1,
                    metalness: 0.1,
                    flatShading: true
                })
            );
            rearDiff.position.set(0, 0.5, -2.9);
            car.add(rearDiff);

            // Spoilerkante
            const spoilerMesh = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.1, 0.4),
                bodyMat
            );
            spoilerMesh.position.set(0, 0.95, -2.9);
            car.add(spoilerMesh);

            // Lichter hinten
            function addTaillight(x, z) {
                const tl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 0.25, 0.12),
                    new THREE.MeshStandardMaterial({
                        color: 0xff4b5c,
                        emissive: 0xff1b3c,
                        emissiveIntensity: 0.8,
                        flatShading: true
                    })
                );
                tl.position.set(x, 0.85, z);
                car.add(tl);
            }
            addTaillight(-1.05, -2.55);
            addTaillight(1.05, -2.55);

            // Lichter vorne
            function addHeadlight(x, z) {
                const hl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.55, 0.25, 0.2),
                    new THREE.MeshStandardMaterial({
                        color: 0xfff7c2,
                        emissive: 0xfff0a0,
                        emissiveIntensity: 0.8,
                        flatShading: true
                    })
                );
                hl.position.set(x, 0.65, z);
                car.add(hl);
            }
            addHeadlight(-0.95, 2.7);
            addHeadlight(0.95, 2.7);

            // Goldene Felgen + Reifen
            const tireMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 1,
                metalness: 0.2,
                flatShading: true
            });

            const rimMat = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                roughness: 0.4,
                metalness: 1.0,
                flatShading: true
            });

            const tireGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 18);
            const rimGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.52, 12);

            function addWheel(x, z) {
                const wheel = new THREE.Group();

                const tire = new THREE.Mesh(tireGeo, tireMat);
                tire.rotation.z = Math.PI / 2;
                tire.castShadow = true;
                wheel.add(tire);

                const rim = new THREE.Mesh(rimGeo, rimMat);
                rim.rotation.z = Math.PI / 2;
                wheel.add(rim);

                wheel.position.set(x, 0.45, z);
                car.add(wheel);
                return wheel;
            }

            const wheelFL = addWheel(-1.5, 1.9);
            const wheelFR = addWheel(1.5, 1.9);
            const wheelRL = addWheel(-1.5, -1.9);
            const wheelRR = addWheel(1.5, -1.9);

            car.position.set(0, 0, 0);
            scene.add(car);

            // === Steuerung & Drift-Physik ===
            const keys = {};
            document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

            let velocity = new THREE.Vector3(0, 0, 0);
            let carAngle = 0;

            const accel = 0.11;          // Vortrieb
            const brake = 0.16;          // Rückwärts / Bremsen
            const maxSpeed = 3.2;
            const baseFriction = 0.96;   // Rollreibung
            const gripSideFriction = 0.91;
            const driftSideFriction = 0.985;
            const turnFactor = 0.09;

            function updateCar(delta) {
                const forward = keys['w'] || keys['arrowup'];
                const back = keys['s'] || keys['arrowdown'];
                const left = keys['a'] || keys['arrowleft'];
                const right = keys['d'] || keys['arrowright'];
                const handbrake = keys[' '];

                const quat = new THREE.Quaternion();
                quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), carAngle);

                const invQuat = quat.clone().invert();
                const localVel = velocity.clone().applyQuaternion(invQuat);

                const factor = delta * 60;

                if (forward) localVel.z -= accel * factor;
                if (back) localVel.z += brake * factor * 0.7;

                const speed = Math.abs(localVel.z);
                if (speed > maxSpeed) {
                    localVel.z = Math.sign(localVel.z) * maxSpeed;
                }

                let steer = 0;
                if (left) steer += 1;
                if (right) steer -= 1;

                const steerStrength = Math.min(1, speed / (maxSpeed * 0.5));
                carAngle += steer * turnFactor * steerStrength;

                const sideFriction = handbrake ? driftSideFriction : gripSideFriction;
                localVel.x *= sideFriction;
                localVel.z *= baseFriction;

                velocity.copy(localVel).applyQuaternion(quat);

                car.position.add(velocity);
                car.position.y = 0;

                car.rotation.y = carAngle;

                // leichtes Body-Roll für Feeling
                car.rotation.z = -steer * steerStrength * 0.12;

                // Räder rotieren
                const wheelRot = localVel.z * 0.3;
                [wheelFL, wheelFR, wheelRL, wheelRR].forEach(w => {
                    w.rotation.x += wheelRot;
                });
            }

            // === Chase Cam ===
            const cameraTargetPos = new THREE.Vector3();
            function updateCamera(delta) {
                const offset = new THREE.Vector3(0, 4, 11);
                const quat = new THREE.Quaternion();
                quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), carAngle);
                const worldOffset = offset.applyQuaternion(quat);

                cameraTargetPos.copy(car.position).add(worldOffset);
                camera.position.lerp(cameraTargetPos, 0.08);
                camera.lookAt(
                    car.position.x,
                    car.position.y + 1.2,
                    car.position.z
                );
            }

            // === Loop ===
            let lastTime = performance.now();
            function animate(now) {
                requestAnimationFrame(animate);
                const delta = (now - lastTime) / 1000;
                lastTime = now;

                updateCar(delta);
                updateCamera(delta);

                renderer.render(scene, camera);
            }

            animate(lastTime);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        };
    </script>
</body>
</html>

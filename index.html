<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Drift City Online</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            z-index: 10;
            background: linear-gradient(90deg, rgba(0,0,0,0.85), transparent);
            padding: 14px 18px;
            border-left: 4px solid #ff0000;
            border-radius: 6px;
            pointer-events: none;
        }

        #hud-title {
            font-size: 24px;
            font-weight: 900;
            letter-spacing: 1px;
            color: #ffd500;
            text-shadow: 0 0 6px rgba(0,0,0,0.8);
        }

        .hud-line {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.85);
            text-align: right;
            font-size: 13px;
            background: rgba(0,0,0,0.6);
            padding: 10px 14px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0,0,0,0.6);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 22px;
            font-weight: bold;
            background: rgba(0,0,0,0.9);
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 200;
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
        }

        #minimap-frame {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 220px;
            height: 220px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 0 12px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 9;
            background: radial-gradient(circle at center, rgba(255,255,255,0.08), rgba(0,0,0,0.9));
        }

        #minimap-label {
            position: absolute;
            top: 18px;
            right: 24px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-shadow: 0 0 6px rgba(0,0,0,0.9);
            z-index: 11;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Lade CLS 63 Modell...</div>

    <div id="hud">
        <div id="hud-title">DRIFT CITY ONLINE</div>
        <div class="hud-line">Speed: <span id="speed-text">0</span> km/h</div>
    </div>

    <div id="minimap-frame"></div>
    <div id="minimap-label">MINIMAP</div>

    <div id="controls">
        <b>W</b> Gas &nbsp;|&nbsp; <b>S</b> Bremse / Rückwärts<br>
        <b>A / D</b> Lenken &nbsp;|&nbsp; <b>SPACE</b> Drift<br>
        <span style="font-size:11px; opacity:0.8;">R = Reset auf Startposition</span>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';

        // ==========================================
        // Einstellungen
        // ==========================================

        const CAR_FILE = 'mersedes_cls63.glb';

        const CAR_SCALE = 8.0;
        const CAR_LIFT = 1.2;
        const CAR_ROT_Y = 0;   // rad

        const CAR_COLOR = 0x111111;
        const TRACK_WIDTH = 20;
        const SKY_COLOR = 0x8fd3ff;

        // Physik
        let speed = 0;
        let maxSpeed = 1.8;
        let baseAcceleration = 0.015;
        let reverseSpeed = 0.7;
        let turnSpeed = 0.045;

        let currentDriftAngle = 0;
        let targetDriftAngle = 0;
        let driftSmoothness = 0.08;

        let keys = { w: false, a: false, s: false, d: false, space: false };

        // global
        let scene, camera, miniCamera, renderer;
        let playerGroup, carModel, loadedCarMesh;
        let tires = [], particles = [];
        let obstacles = [];

        // HUD
        const speedLabel = document.getElementById('speed-text');
        let lastTime = performance.now();

        init();
        requestAnimationFrame(animate);

        // ==========================================
        // Init
        // ==========================================

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(SKY_COLOR, 80, 1200);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                3000
            );

            miniCamera = new THREE.OrthographicCamera(-80, 80, 80, -80, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.autoClear = false;
            renderer.setClearColor(SKY_COLOR, 1);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.1);
            sun.position.set(300, 500, 300);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            sun.shadow.camera.left = -800;
            sun.shadow.camera.right = 800;
            sun.shadow.camera.top = 800;
            sun.shadow.camera.bottom = -800;
            scene.add(sun);

            createGround();
            createCityRoads();
            createBuildings();
            createParkAreas();
            createBridgeArea();
            createParkingGarage();
            createCar();

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // === Umgebung ===

        function createGround() {
            const baseGeo = new THREE.PlaneGeometry(4000, 4000);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x1e5b2e, roughness: 1 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI / 2;
            base.position.y = -0.2;
            base.receiveShadow = true;
            scene.add(base);
        }

        function createCityRoads() {
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x33363f, roughness: 0.9 });
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xf7f7f7 });

            function addRoad(x, z, w, h) {
                const road = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, h), roadMat);
                road.position.set(x, 0, z);
                road.receiveShadow = true;
                scene.add(road);
            }

            // Hauptachsen
            addRoad(0, 0, 800, TRACK_WIDTH);
            addRoad(0, -200, 800, TRACK_WIDTH);
            addRoad(0, 200, 800, TRACK_WIDTH);

            addRoad(-200, 0, TRACK_WIDTH, 800);
            addRoad(200, 0, TRACK_WIDTH, 800);
            addRoad(0, 0, TRACK_WIDTH, 800);

            // Nebenstraßen
            addRoad(-450, 0, 300, TRACK_WIDTH * 0.8);
            addRoad(450, 0, 300, TRACK_WIDTH * 0.8);
            addRoad(0, -450, TRACK_WIDTH * 0.8, 300);
            addRoad(0, 450, TRACK_WIDTH * 0.8, 300);

            const lineGeo = new THREE.BoxGeometry(4, 0.11, 40);
            for (let x = -380; x <= 380; x += 60) {
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.position.set(x, 0.06, 0);
                scene.add(line);
            }
        }

        function createBuildings() {
            const buildingColors = [0x1f2933, 0x262f3d, 0x353f4f, 0x202833];
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x1b1b1b, roughness: 0.7 });

            function addBuilding(x, z, w, d, h) {
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                    roughness: 0.95,
                    metalness: 0.05
                });

                const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bodyMat);
                body.position.set(x, h / 2, z);
                body.castShadow = true;
                body.receiveShadow = true;

                const roof = new THREE.Mesh(new THREE.BoxGeometry(w * 1.02, 1, d * 1.02), roofMat);
                roof.position.set(x, h + 0.5, z);
                roof.castShadow = true;

                scene.add(body);
                scene.add(roof);

                const radius = Math.max(w, d) * 0.6;
                obstacles.push({ pos: new THREE.Vector3(x, 0, z), radius: radius });
            }

            for (let i = -3; i <= 3; i++) {
                if (i === 0) continue;
                const x = i * 120;
                addBuilding(x, -280, 50, 70, 60 + Math.random() * 60);
                addBuilding(x, 280, 50, 70, 50 + Math.random() * 70);
            }

            for (let j = -3; j <= 3; j++) {
                if (j === 0) continue;
                const z = j * 120;
                addBuilding(-280, z, 70, 50, 50 + Math.random() * 70);
                addBuilding(280, z, 70, 50, 60 + Math.random() * 60);
            }

            addBuilding(-350, -350, 70, 70, 140);
            addBuilding(360, 330, 60, 60, 130);
        }

        function createParkAreas() {
            const parkMat = new THREE.MeshStandardMaterial({ color: 0x3ba857, roughness: 0.9 });
            const pathMat = new THREE.MeshStandardMaterial({ color: 0xd3d3d3, roughness: 0.8 });

            const park = new THREE.Mesh(new THREE.BoxGeometry(260, 0.1, 260), parkMat);
            park.position.set(-350, 0.02, 200);
            park.receiveShadow = true;
            scene.add(park);

            const path = new THREE.Mesh(new THREE.BoxGeometry(30, 0.12, 200), pathMat);
            path.position.set(-350, 0.04, 200);
            scene.add(path);

            const trunkGeo = new THREE.CylinderGeometry(1.2, 1.5, 6, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5b3b1f });
            const leafGeo = new THREE.SphereGeometry(4.5, 8, 8);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x247b37 });

            for (let i = 0; i < 20; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 3;
                trunk.castShadow = true;
                const crown = new THREE.Mesh(leafGeo, leafMat);
                crown.position.y = 8;
                crown.castShadow = true;
                tree.add(trunk, crown);

                const rx = -420 + Math.random() * 140;
                const rz = 120 + Math.random() * 160;
                tree.position.set(rx, 0, rz);
                scene.add(tree);

                obstacles.push({ pos: new THREE.Vector3(rx, 0, rz), radius: 5 });
            }
        }

        function createBridgeArea() {
            const bridgeGroup = new THREE.Group();

            const deckMat = new THREE.MeshStandardMaterial({ color: 0x3a3d44, roughness: 0.6 });
            const sideMat = new THREE.MeshStandardMaterial({ color: 0x22252e, roughness: 0.8 });

            const deck = new THREE.Mesh(new THREE.BoxGeometry(180, 2, 14), deckMat);
            deck.position.set(0, 12, -260);
            deck.castShadow = true;
            deck.receiveShadow = true;
            bridgeGroup.add(deck);

            const railGeo = new THREE.BoxGeometry(180, 1.2, 0.5);
            const railL = new THREE.Mesh(railGeo, sideMat);
            railL.position.set(0, 13.5, -267);
            const railR = railL.clone();
            railR.position.z = -253;
            railL.castShadow = railR.castShadow = true;
            bridgeGroup.add(railL, railR);

            const pillarGeo = new THREE.BoxGeometry(4, 12, 4);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x4b4f59, roughness: 0.9 });
            const px = [-70, 70];
            const pz = [-255, -265];
            px.forEach(x => {
                pz.forEach(z => {
                    const p = new THREE.Mesh(pillarGeo, pillarMat);
                    p.position.set(x, 6, z);
                    p.castShadow = true;
                    p.receiveShadow = true;
                    bridgeGroup.add(p);
                    obstacles.push({ pos: new THREE.Vector3(x, 0, z), radius: 5 });
                });
            });

            const underMat = new THREE.MeshStandardMaterial({ color: 0x2f323a, roughness: 0.9 });
            const underRoad = new THREE.Mesh(new THREE.BoxGeometry(200, 0.1, TRACK_WIDTH), underMat);
            underRoad.position.set(0, 0.02, -260);
            underRoad.receiveShadow = true;
            bridgeGroup.add(underRoad);

            scene.add(bridgeGroup);
        }

        function createParkingGarage() {
            const group = new THREE.Group();
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x4a4f5a, roughness: 0.8 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x2c3139, roughness: 0.9 });

            const floors = 3;
            const w = 80, d = 60, h = 3.5;
            for (let i = 0; i < floors; i++) {
                const y = i * h;

                const floor = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, d), floorMat);
                floor.position.set(0, y + 0.3, 0);
                floor.castShadow = true;
                floor.receiveShadow = true;
                group.add(floor);

                const wallFront = new THREE.Mesh(new THREE.BoxGeometry(w, 2.5, 0.6), wallMat);
                wallFront.position.set(0, y + 1.6, d / 2);
                const wallBack = wallFront.clone();
                wallBack.position.z = -d / 2;
                const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.6, 2.5, d), wallMat);
                wallLeft.position.set(-w / 2, y + 1.6, 0);
                const wallRight = wallLeft.clone();
                wallRight.position.x = w / 2;
                [wallFront, wallBack, wallLeft, wallRight].forEach(wall => {
                    wall.castShadow = true;
                    group.add(wall);
                });
            }

            const ramp = new THREE.Mesh(
                new THREE.BoxGeometry(20, 0.6, 40),
                floorMat
            );
            ramp.position.set(40, 1.5, -20);
            ramp.rotation.z = -0.4;
            ramp.castShadow = true;
            group.add(ramp);

            group.position.set(320, 0, 220);
            scene.add(group);

            obstacles.push({ pos: new THREE.Vector3(320, 0, 220), radius: 70 });
        }

        // === Auto ===

        function createCar() {
            playerGroup = new THREE.Group();
            carModel = new THREE.Group();
            playerGroup.position.set(0, 0.5, 40);
            playerGroup.rotation.y = Math.PI;
            playerGroup.add(carModel);
            scene.add(playerGroup);

            const loader = new GLTFLoader();
            loader.load(
                CAR_FILE,
                (gltf) => {
                    document.getElementById('loading').style.display = 'none';
                    loadedCarMesh = gltf.scene;

                    loadedCarMesh.scale.set(CAR_SCALE, CAR_SCALE, CAR_SCALE);
                    loadedCarMesh.position.y = CAR_LIFT;
                    loadedCarMesh.rotation.y = CAR_ROT_Y;

                    const paint = new THREE.MeshStandardMaterial({
                        color: CAR_COLOR,
                        metalness: 0.6,
                        roughness: 0.2
                    });

                    loadedCarMesh.traverse(child => {
                        if (child.isMesh) {
                            child.material = paint;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    carModel.add(loadedCarMesh);

                    const t1 = new THREE.Object3D();
                    t1.position.set(-1.5, 0, 1.5);
                    const t2 = new THREE.Object3D();
                    t2.position.set(1.5, 0, 1.5);
                    carModel.add(t1, t2);
                    tires.push(t1, t2);
                },
                undefined,
                (err) => {
                    console.error('Fehler beim Laden des Modells:', err);
                    document.getElementById('loading').innerText = 'Fehler beim Laden des Autos';
                }
            );
        }

        // === Input ===

        function onKeyDown(e) {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = true;
            if (e.code === 'Space') keys.space = true;
            if (k === 'r') {
                playerGroup.position.set(0, 0.5, 40);
                playerGroup.rotation.set(0, Math.PI, 0);
                speed = 0;
            }
        }

        function onKeyUp(e) {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = false;
            if (e.code === 'Space') keys.space = false;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // === Effekte ===

        function spawnSmoke(pos) {
            if (Math.random() > 0.4) return;
            const p = new THREE.Mesh(
                new THREE.BoxGeometry(0.35, 0.35, 0.35),
                new THREE.MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.45 })
            );
            p.position.copy(pos);
            p.position.y = 0.25;
            p.rotation.set(Math.random(), Math.random(), Math.random());
            scene.add(p);
            particles.push({ mesh: p, life: 1.0 });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                p.mesh.position.y += 0.05;
                p.mesh.scale.multiplyScalar(1.04);
                p.mesh.material.opacity = p.life * 0.5;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // === Main Loop ===

        function animate(now) {
            requestAnimationFrame(animate);
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            updatePhysics(delta);
            updateCamera();
            updateMiniMapCamera();
            updateParticles();

            const displaySpeed = Math.min(Math.floor(Math.abs(speed) * 140), 320);
            speedLabel.textContent = displaySpeed.toString();

            renderer.clear();
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
            renderer.render(scene, camera);

            const size = 220;
            const x = window.innerWidth - size - 20;
            renderer.setViewport(x, window.innerHeight - size - 20, size, size);
            renderer.setScissor(x, window.innerHeight - size - 20, size, size);
            renderer.setScissorTest(true);
            renderer.render(scene, miniCamera);
            renderer.setScissorTest(false);
        }

        // === Physik ===

        function updatePhysics(delta) {
            if (keys.w) {
                const speedFactor = 1 - (speed / maxSpeed);
                const currentAccel = baseAcceleration * (speedFactor > 0.15 ? speedFactor : 0.15);
                speed += currentAccel;
            } else if (keys.s) {
                speed -= baseAcceleration * 1.6;
            } else {
                speed *= 0.985;
            }

            if (speed > maxSpeed) speed = maxSpeed;
            if (speed < -reverseSpeed) speed = -reverseSpeed;

            if (Math.abs(speed) > 0.05) {
                const dir = speed > 0 ? 1 : -1;
                let dynamicTurn = turnSpeed * (1 - (speed / maxSpeed) * 0.3);
                if (keys.a) playerGroup.rotation.y += dynamicTurn * dir;
                if (keys.d) playerGroup.rotation.y -= dynamicTurn * dir;
            }

            playerGroup.translateZ(-speed);

            for (const o of obstacles) {
                const dist = new THREE.Vector2(
                    playerGroup.position.x - o.pos.x,
                    playerGroup.position.z - o.pos.z
                ).length();

                if (dist < o.radius) {
                    const push = new THREE.Vector3(
                        playerGroup.position.x - o.pos.x,
                        0,
                        playerGroup.position.z - o.pos.z
                    ).normalize().multiplyScalar(0.7);
                    playerGroup.position.add(push);
                    speed *= -0.3;
                }
            }

            targetDriftAngle = 0;
            if (keys.space && Math.abs(speed) > 0.6) {
                if (keys.a) targetDriftAngle = 0.55;
                else if (keys.d) targetDriftAngle = -0.55;

                tires.forEach(t => {
                    const p = new THREE.Vector3();
                    t.getWorldPosition(p);
                    spawnSmoke(p);
                });

                speed *= 0.99;
            }

            currentDriftAngle = THREE.MathUtils.lerp(currentDriftAngle, targetDriftAngle, driftSmoothness);
            carModel.rotation.y = currentDriftAngle;
        }

        function updateCamera() {
            const relativeCamOffset = new THREE.Vector3(0, 3.2, 8.5);
            const cameraOffset = relativeCamOffset.applyMatrix4(playerGroup.matrixWorld);
            camera.position.lerp(cameraOffset, 0.12);

            const lookAtTarget = new THREE.Vector3(0, 1.8, -6);
            lookAtTarget.applyMatrix4(playerGroup.matrixWorld);
            camera.lookAt(lookAtTarget);
        }

        function updateMiniMapCamera() {
            const target = playerGroup.position.clone();
            miniCamera.position.set(target.x, 120, target.z);
            miniCamera.lookAt(target);
            miniCamera.rotation.z = 0;
        }
    </script>
</body>
</html>

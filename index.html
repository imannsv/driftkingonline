<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>2D Drift Circuit</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
            font-family: Arial, sans-serif;
            color: #fff;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            border-left: 4px solid #ff4747;
            font-size: 13px;
            z-index: 10;
            max-width: 330px;
        }

        #hud-title {
            font-weight: 900;
            letter-spacing: 1px;
            font-size: 18px;
            margin-bottom: 4px;
            color: #ffd54a;
        }

        #driftZoneLabel {
            margin-top: 4px;
            color: #8cf5ff;
            font-weight: 700;
            display: none;
        }

        #perfectRunLabel {
            margin-top: 2px;
            color: #ffb347;
            font-weight: 700;
            display: none;
        }

        #controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            text-align: right;
            font-size: 12px;
            z-index: 10;
        }

        #challengeBanner {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border-right: 4px solid #4af2ff;
            font-size: 12px;
            text-align: right;
            z-index: 10;
            max-width: 260px;
        }

        #challengeStatus {
            font-weight: 700;
            margin-top: 2px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div id="hud-title">2D DRIFT CIRCUIT</div>

        <div>Speed: <span id="speedText">0</span> km/h</div>
        <div>
            Drift: <span id="driftText">0</span>% &nbsp;|&nbsp;
            Combo: x<span id="comboText">1</span>
        </div>
        <div>Drift Punkte: <span id="driftScoreText">0</span></div>
        <div>Collects: <span id="pickupScoreText">0</span></div>

        <div>
            Level: <span id="levelText">1</span> &nbsp;|&nbsp;
            XP: <span id="xpText">0</span>
        </div>
        <div>Car Setup: <span id="carSetupText">Street</span></div>

        <div id="offText" style="margin-top:4px; color:#ff7070; display:none;">OFF TRACK - Respawn</div>
        <div id="driftZoneLabel">ðŸ”¥ DRIFT ZONE ACTIVE</div>
        <div id="perfectRunLabel">ðŸŽ¯ PERFECT RUN AKTIV (keine HÃ¼tchen hitten!)</div>
    </div>

    <div id="challengeBanner">
        <div>Challenge: <span id="challengeName">Freies Fahren</span></div>
        <div>Ziel: <span id="challengeGoal">â€“</span></div>
        <div>Zeit: <span id="challengeTime">00.0</span>s</div>
        <div id="challengeStatus">Status: â€“</div>
    </div>

    <div id="controls">
        W / S â€“ Gas / Bremse<br>
        A / D â€“ Lenken<br>
        SPACE â€“ Handbremse / mehr Drift<br>
        R â€“ Reset auf Start<br>
        1â€“4 â€“ Challenge wÃ¤hlen
    </div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // HUD-Elemente
        const speedText = document.getElementById('speedText');
        const driftText = document.getElementById('driftText');
        const driftScoreText = document.getElementById('driftScoreText');
        const pickupScoreText = document.getElementById('pickupScoreText');
        const xpText = document.getElementById('xpText');
        const levelText = document.getElementById('levelText');
        const carSetupText = document.getElementById('carSetupText');
        const offText = document.getElementById('offText');
        const driftZoneLabel = document.getElementById('driftZoneLabel');
        const perfectRunLabel = document.getElementById('perfectRunLabel');
        const comboText = document.getElementById('comboText');

        const challengeNameEl = document.getElementById('challengeName');
        const challengeGoalEl = document.getElementById('challengeGoal');
        const challengeTimeEl = document.getElementById('challengeTime');
        const challengeStatusEl = document.getElementById('challengeStatus');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // =========================
        // Steuerung
        // =========================
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false
        };

        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = true;
            if (k === ' ') keys.space = true;
            if (k === 'r') manualReset();

            if (k === '1') setChallenge(0);
            if (k === '2') setChallenge(1);
            if (k === '3') setChallenge(2);
            if (k === '4') setChallenge(3);
        });

        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = false;
            if (k === ' ') keys.space = false;
        });

        // =========================
        // Track / Welt
        // =========================
        const TRACK = {
            cx: 0,
            cy: 0,
            halfWidth: 1400,
            halfHeight: 900
        };
        const TRACK_MARGIN = 40;
        const WORLD_MARGIN = 600;

        function isOnTrack(x, y) {
            return (
                x >= TRACK.cx - TRACK.halfWidth + TRACK_MARGIN &&
                x <= TRACK.cx + TRACK.halfWidth - TRACK_MARGIN &&
                y >= TRACK.cy - TRACK.halfHeight + TRACK_MARGIN &&
                y <= TRACK.cy + TRACK.halfHeight - TRACK_MARGIN
            );
        }

        const MAP_BOUNDS = {
            minX: TRACK.cx - TRACK.halfWidth,
            maxX: TRACK.cx + TRACK.halfWidth,
            minY: TRACK.cy - TRACK.halfHeight,
            maxY: TRACK.cy + TRACK.halfHeight
        };

        // =========================
        // Drift Zonen (Bonus)
        // =========================
        const driftZones = [
            { x: TRACK.cx - 900, y: TRACK.cy - 200, w: 650, h: 300 },
            { x: TRACK.cx + 250, y: TRACK.cy + 200, w: 700, h: 350 }
        ];

        function isInRectZone(x, y, z) {
            return x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h;
        }

        function isInDriftZone(x, y) {
            for (const z of driftZones) {
                if (isInRectZone(x, y, z)) return true;
            }
            return false;
        }

        // =========================
        // GefÃ¤hrliche / Bonus Zonen
        // =========================
        const oilSpots = [
            { x: TRACK.cx - 300, y: TRACK.cy - 100, radius: 80 },
            { x: TRACK.cx + 450, y: TRACK.cy, radius: 70 }
        ];

        const sandZones = [
            { x: TRACK.cx - 500, y: TRACK.cy + 250, w: 450, h: 220 },
            { x: TRACK.cx + 350, y: TRACK.cy - 350, w: 400, h: 180 }
        ];

        const riskZones = [
            { x: TRACK.cx - TRACK.halfWidth + TRACK_MARGIN + 30, y: TRACK.cy - 300, w: 160, h: 600 },
            { x: TRACK.cx + TRACK.halfWidth - TRACK_MARGIN - 190, y: TRACK.cy - 300, w: 160, h: 600 }
        ];

        function isInCircleZone(x, y, zone) {
            const dx = x - zone.x;
            const dy = y - zone.y;
            return Math.hypot(dx, dy) <= zone.radius;
        }

        function inOil(x, y) {
            return oilSpots.some(z => isInCircleZone(x, y, z));
        }

        function inSand(x, y) {
            return sandZones.some(z => isInRectZone(x, y, z));
        }

        function inRiskZone(x, y) {
            return riskZones.some(z => isInRectZone(x, y, z));
        }

        // =========================
        // Hindernisse (HÃ¼tchen)
        // =========================
        const obstacles = []; // {x,y,radius}

        function addObstacle(x, y, radius = 18) {
            obstacles.push({ x, y, radius });
        }

        function initObstacles() {
            obstacles.length = 0;

            const innerLeft = TRACK.cx - TRACK.halfWidth + TRACK_MARGIN + 80;
            const innerRight = TRACK.cx + TRACK.halfWidth - TRACK_MARGIN - 80;
            const innerTop = TRACK.cy - TRACK.halfHeight + TRACK_MARGIN + 80;
            const innerBottom = TRACK.cy + TRACK.halfHeight - TRACK_MARGIN - 80;

            // Reihen an oberen/unteren RÃ¤ndern
            for (let x = innerLeft; x <= innerRight; x += 260) {
                addObstacle(x, innerTop + 80, 20);
                addObstacle(x, innerBottom - 80, 20);
            }

            // random HÃ¼tchen im Inneren
            const spawnPos = { x: TRACK.cx, y: TRACK.cy + TRACK.halfHeight - 120 };
            const minDistToSpawn = 260;

            for (let i = 0; i < 40; i++) {
                const rx = innerLeft + Math.random() * (innerRight - innerLeft);
                const ry = innerTop + Math.random() * (innerBottom - innerTop);

                const dx = rx - spawnPos.x;
                const dy = ry - spawnPos.y;
                const dist = Math.hypot(dx, dy);
                if (dist < minDistToSpawn) continue;

                addObstacle(rx, ry, 18 + Math.random() * 4);
            }
        }

        // =========================
        // Collectibles
        // =========================
        const pickups = [];
        let pickupScore = 0;
        const PICKUP_COUNT = 7;

        function randomPointInsideTrack() {
            const x = TRACK.cx - TRACK.halfWidth + TRACK_MARGIN + 60 +
                Math.random() * (TRACK.halfWidth * 2 - 2 * (TRACK_MARGIN + 60));
            const y = TRACK.cy - TRACK.halfHeight + TRACK_MARGIN + 60 +
                Math.random() * (TRACK.halfHeight * 2 - 2 * (TRACK_MARGIN + 60));
            return { x, y };
        }

        function respawnPickup(pickup) {
            let tries = 0;
            while (tries < 50) {
                const p = randomPointInsideTrack();
                let tooClose = false;
                for (const o of obstacles) {
                    const d = Math.hypot(p.x - o.x, p.y - o.y);
                    if (d < o.radius + 40) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) {
                    pickup.x = p.x;
                    pickup.y = p.y;
                    return;
                }
                tries++;
            }
        }

        function initPickups() {
            pickups.length = 0;
            for (let i = 0; i < PICKUP_COUNT; i++) {
                const p = randomPointInsideTrack();
                pickups.push({
                    x: p.x,
                    y: p.y,
                    radius: 18
                });
            }
        }

        // =========================
        // Car-Setups / Level / XP
        // =========================
        const carPresets = [
            {
                name: "Street",
                colorMain: "#c00000",
                colorAccent: "#8c0000",
                maxSpeed: 220,
                acceleration: 290,
                brake: 180,
                grip: 7,
                handbrakeGrip: 2.2,
                friction: 3.0
            },
            {
                name: "Grip Spec",
                colorMain: "#00a3ff",
                colorAccent: "#0064b0",
                maxSpeed: 210,
                acceleration: 270,
                brake: 220,
                grip: 9,
                handbrakeGrip: 2.8,
                friction: 3.3
            },
            {
                name: "Drift King",
                colorMain: "#ff9a00",
                colorAccent: "#c96a00",
                maxSpeed: 240,
                acceleration: 310,
                brake: 190,
                grip: 6,
                handbrakeGrip: 2.0,
                friction: 2.8
            }
        ];

        let totalXP = 0;
        let level = 1;
        let currentPresetIndex = 0;

        function updateCarStatsFromPreset() {
            const preset = carPresets[currentPresetIndex];
            car.maxSpeed = preset.maxSpeed;
            car.acceleration = preset.acceleration;
            car.brake = preset.brake;
            car.grip = preset.grip;
            car.handbrakeGrip = preset.handbrakeGrip;
            car.friction = preset.friction;
            carSetupText.textContent = preset.name;
        }

        function updateLevelAndPreset() {
            const XP_PER_LEVEL = 5000;
            const newLevel = 1 + Math.floor(totalXP / XP_PER_LEVEL);
            if (newLevel !== level) {
                level = newLevel;
            }
            levelText.textContent = level.toString();
            xpText.textContent = Math.floor(totalXP).toString();

            let unlocked = Math.min(Math.floor((level - 1) / 2), carPresets.length - 1);
            if (unlocked !== currentPresetIndex) {
                currentPresetIndex = unlocked;
                updateCarStatsFromPreset();
            }
        }

        // =========================
        // Car-Physik
        // =========================
        const car = {
            x: 0,
            y: 0,
            angle: 0,          // 0 = nach oben
            vx: 0,
            vy: 0,
            width: 28,
            length: 60,
            maxSpeed: 220,
            acceleration: 290,
            brake: 180,
            friction: 3.0,
            grip: 7,
            handbrakeGrip: 2.2,
            steering: 220
        };

        const respawn = {
            active: false,
            timer: 0,
            blinkTimer: 0,
            visible: true
        };

        function setCarToSpawn() {
            car.x = TRACK.cx;
            car.y = TRACK.cy + TRACK.halfHeight - 120;
            car.angle = 0;
            car.vx = 0;
            car.vy = 0;
        }

        function resetCar() {
            setCarToSpawn();
            respawn.active = false;
            respawn.visible = true;
            respawn.timer = 0;
            respawn.blinkTimer = 0;
            offText.style.display = 'none';
        }

        function manualReset() {
            resetCar();
            driftZoneLabel.style.display = 'none';
            perfectRunLabel.style.display = perfectRunActive ? 'block' : 'none';
        }

        resetCar();
        initObstacles();
        initPickups();
        updateCarStatsFromPreset();
        updateLevelAndPreset();

        // =========================
        // Drift Combo-System
        // =========================
        let comboMultiplier = 1;
        let comboTimer = 0;
        const COMBO_DRIFT_THRESHOLD = 0.35;
        const COMBO_DECAY_TIME = 0.7;
        let bestCombo = 1;

        // Driftpunkte hier nach oben verlegt, damit setChallenge() es kennt
        let driftScore = 0;

        function updateCombo(driftStrength, speed, dt) {
            if (driftStrength > COMBO_DRIFT_THRESHOLD && speed > 10) {
                comboTimer = COMBO_DECAY_TIME;
                comboMultiplier += driftStrength * dt * 1.7;
                if (comboMultiplier < 1) comboMultiplier = 1;
                if (comboMultiplier > 8) comboMultiplier = 8;
            } else {
                comboTimer -= dt;
                if (comboTimer <= 0) {
                    comboMultiplier = 1;
                    comboTimer = 0;
                }
            }
            if (comboMultiplier > bestCombo) bestCombo = comboMultiplier;
            comboText.textContent = comboMultiplier.toFixed(1);
        }

        // =========================
        // Challenges / Modi
        // =========================
        const challenges = [
            {
                id: 0,
                name: "Freies Fahren",
                type: "free",
                goalText: "Mach was du willst",
                timeLimit: 0
            },
            {
                id: 1,
                name: "Pickup Rush",
                type: "pickup",
                requiredPickups: 15,
                goalText: "Sammle 15 Collects",
                timeLimit: 60
            },
            {
                id: 2,
                name: "Drift Score Attack",
                type: "drift",
                requiredScore: 10000,
                goalText: "Erreiche 10.000 Drift-Punkte",
                timeLimit: 90
            },
            {
                id: 3,
                name: "Perfect Run",
                type: "perfect",
                requiredPickups: 10,
                goalText: "10 Collects ohne HÃ¼tchen-Hit",
                timeLimit: 75
            }
        ];

        let currentChallenge = challenges[0];
        let challengeTime = 0;
        let challengeRunning = false;
        let challengeResult = "â€“";
        let challengePickupProgress = 0;
        let challengeStartDriftScore = 0;
        let perfectRunActive = false;
        let perfectRunFailed = false;

        function setChallenge(index) {
            currentChallenge = challenges[index] || challenges[0];
            challengeNameEl.textContent = currentChallenge.name;
            challengeGoalEl.textContent = currentChallenge.goalText;
            challengeTime = 0;
            challengeRunning = currentChallenge.type !== "free";
            challengeResult = challengeRunning ? "LÃ¤uft..." : "â€“";
            challengeStatusEl.textContent = "Status: " + challengeResult;

            challengePickupProgress = 0;
            challengeStartDriftScore = driftScore;
            perfectRunFailed = false;
            perfectRunActive = currentChallenge.type === "perfect";
            perfectRunLabel.style.display = perfectRunActive ? "block" : "none";
        }

        setChallenge(0);

        function updateChallenge(dt) {
            if (!challengeRunning) {
                challengeTimeEl.textContent = "00.0";
                return;
            }

            challengeTime += dt;
            challengeTimeEl.textContent = challengeTime.toFixed(1);

            if (currentChallenge.timeLimit > 0 && challengeTime > currentChallenge.timeLimit && challengeResult === "LÃ¤uft...") {
                challengeRunning = false;
                challengeResult = "âŒ Zeit abgelaufen";
                challengeStatusEl.textContent = "Status: " + challengeResult;
                return;
            }

            if (currentChallenge.type === "pickup") {
                if (challengePickupProgress >= currentChallenge.requiredPickups && challengeResult === "LÃ¤uft...") {
                    challengeRunning = false;
                    challengeResult = "âœ… Geschafft!";
                    challengeStatusEl.textContent = "Status: " + challengeResult;
                    totalXP += 1500;
                    updateLevelAndPreset();
                }
            }

            if (currentChallenge.type === "drift") {
                const gained = driftScore - challengeStartDriftScore;
                if (gained >= currentChallenge.requiredScore && challengeResult === "LÃ¤uft...") {
                    challengeRunning = false;
                    challengeResult = "âœ… Drift Ziel erreicht!";
                    challengeStatusEl.textContent = "Status: " + challengeResult;
                    totalXP += 2000;
                    updateLevelAndPreset();
                }
            }

            if (currentChallenge.type === "perfect") {
                if (perfectRunFailed && challengeResult === "LÃ¤uft...") {
                    challengeRunning = false;
                    challengeResult = "âŒ HÃ¼tchen getroffen";
                    challengeStatusEl.textContent = "Status: " + challengeResult;
                    return;
                }
                if (!perfectRunFailed &&
                    challengePickupProgress >= currentChallenge.requiredPickups &&
                    challengeResult === "LÃ¤uft...") {
                    challengeRunning = false;
                    challengeResult = "âœ… Perfekter Run!";
                    challengeStatusEl.textContent = "Status: " + challengeResult;
                    totalXP += 2500;
                    updateLevelAndPreset();
                }
            }
        }

        // =========================
        // Respawn
        // =========================
        function triggerAutoRespawn() {
            respawn.active = true;
            respawn.timer = 1.2;
            respawn.blinkTimer = 0.15;
            respawn.visible = true;
            setCarToSpawn();
            offText.style.display = 'block';
            driftZoneLabel.style.display = 'none';
            perfectRunLabel.style.display = perfectRunActive ? 'block' : 'none';
        }

        function updateRespawn(dt) {
            if (!respawn.active) return;
            respawn.timer -= dt;
            respawn.blinkTimer -= dt;

            if (respawn.blinkTimer <= 0) {
                respawn.visible = !respawn.visible;
                respawn.blinkTimer = 0.15;
            }

            if (respawn.timer <= 0) {
                respawn.active = false;
                respawn.visible = true;
                offText.style.display = 'none';
            }
        }

        // =========================
        // Skidmarks (4 RÃ¤der)
        // =========================
        const skidmarks = []; // {x,y,angle,alpha,life}

        function updateSkidmarks(dt) {
            for (let i = skidmarks.length - 1; i >= 0; i--) {
                skidmarks[i].life -= dt;
                if (skidmarks[i].life <= 0) {
                    skidmarks.splice(i, 1);
                }
            }
        }

        // =========================
        // Car-Update
        // =========================
        function updateCar(dt) {
            if (respawn.active) {
                car.vx = 0;
                car.vy = 0;
                return;
            }

            // VorwÃ¤rtsrichtung (0 = nach oben)
            const fx = Math.sin(car.angle);
            const fy = -Math.cos(car.angle);

            // SeitwÃ¤rtsrichtung (rechts)
            const sx = Math.cos(car.angle);
            const sy = Math.sin(car.angle);

            // Lokale Geschwindigkeitskomponenten
            const forwardSpeed = car.vx * fx + car.vy * fy;
            const sideSpeed = car.vx * sx + car.vy * sy;

            // Grip, modifiziert durch Zonen
            let baseGrip = keys.space ? car.handbrakeGrip : car.grip;
            if (inOil(car.x, car.y)) {
                baseGrip *= 0.25;  // sehr rutschig
            } else if (inSand(car.x, car.y)) {
                baseGrip *= 0.7;   // etwas rutschiger
            }

            // Beschleunigen/Bremsen
            let accel = 0;
            if (keys.w) {
                accel += car.acceleration;
            } else if (keys.s) {
                accel -= car.brake;
            }

            let newForward = forwardSpeed + accel * dt;

            // Motorbremse
            if (!keys.w && !keys.s) {
                const engineBrake = car.acceleration * 0.8 * dt;
                if (newForward > 0) {
                    newForward = Math.max(0, newForward - engineBrake);
                } else if (newForward < 0) {
                    newForward = Math.min(0, newForward + engineBrake);
                }
            }

            const maxFwd = car.maxSpeed;
            const maxBack = -car.maxSpeed * 0.5;

            if (newForward > maxFwd) newForward = maxFwd;
            if (newForward < maxBack) newForward = maxBack;

            const newSide = sideSpeed * Math.exp(-baseGrip * dt);

            // zurÃ¼ck in Welt-Geschwindigkeit
            let vx = fx * newForward + sx * newSide;
            let vy = fy * newForward + sy * newSide;

            let speed = Math.hypot(vx, vy);
            if (speed > 0) {
                let frictionForce = car.friction * dt;
                if (inSand(car.x, car.y)) {
                    frictionForce *= 1.4;  // langsamer in Sand
                }
                const newSpeed = Math.max(speed - frictionForce, 0);
                const scale = newSpeed / speed;
                vx *= scale;
                vy *= scale;
                speed = newSpeed;
            }

            car.vx = vx;
            car.vy = vy;

            // Lenken
            const steerInput = (keys.a ? -1 : 0) + (keys.d ? 1 : 0);
            if (steerInput !== 0 && speed > 1) {
                const speedFactor = Math.max(speed / car.maxSpeed, 0.3);
                const steerAmount = (car.steering * Math.PI / 180) * steerInput * dt * speedFactor;
                car.angle += steerAmount;
            }

            // Position
            car.x += car.vx * dt;
            car.y += car.vy * dt;

            // Weltbegrenzung
            const limit = 2000 + WORLD_MARGIN;
            if (car.x < -limit) car.x = -limit;
            if (car.x > limit) car.x = limit;
            if (car.y < -limit) car.y = -limit;
            if (car.y > limit) car.y = limit;

            // Kollision mit HÃ¼tchen
            const carRadius = car.length * 0.35;
            for (const o of obstacles) {
                const dx = car.x - o.x;
                const dy = car.y - o.y;
                const dist = Math.hypot(dx, dy);
                const minDist = carRadius + o.radius;
                if (dist < minDist && dist > 0.0001) {
                    const overlap = minDist - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;

                    car.x += nx * overlap * 1.0;
                    car.y += ny * overlap * 1.0;

                    const dot = car.vx * nx + car.vy * ny;
                    car.vx = (car.vx - 2 * dot * nx) * 0.7;
                    car.vy = (car.vy - 2 * dot * ny) * 0.7;

                    car.angle += (Math.random() - 0.5) * 0.15;

                    // Perfect-Run fail
                    if (perfectRunActive && !perfectRunFailed && challengeRunning && currentChallenge.type === "perfect") {
                        perfectRunFailed = true;
                    }
                }
            }

            // Collectibles
            for (const p of pickups) {
                const dx = car.x - p.x;
                const dy = car.y - p.y;
                const dist = Math.hypot(dx, dy);
                const pickupRadius = p.radius + 20;
                if (dist < pickupRadius) {
                    let basePoints = 10;
                    let gain = basePoints * comboMultiplier;
                    pickupScore += gain;
                    pickupScoreText.textContent = Math.round(pickupScore).toString();

                    // XP & Challenge-Prog
                    totalXP += gain;
                    if (challengeRunning && (currentChallenge.type === "pickup" || currentChallenge.type === "perfect")) {
                        challengePickupProgress++;
                    }

                    respawnPickup(p);
                }
            }

            // Drift / Skidmarks
            const driftStrength = Math.min(Math.abs(sideSpeed) / 20, 1);
            updateCombo(driftStrength, speed, dt);

            if (driftStrength > 0.25 && speed > 5) {
                const halfL = car.length * 0.5;
                const halfW = car.width * 0.5;

                const frontOffset = halfL * 0.7;
                const rearOffset = -halfL * 0.7;
                const sideOffset = halfW * 0.7;

                function addWheelMark(longitudinal, lateral) {
                    const wx = car.x + fx * longitudinal + sx * lateral;
                    const wy = car.y + fy * longitudinal + sy * lateral;
                    skidmarks.push({
                        x: wx,
                        y: wy,
                        angle: car.angle,
                        alpha: 0.4 + 0.4 * driftStrength,
                        life: 2.0
                    });
                }

                addWheelMark(rearOffset, -sideOffset);
                addWheelMark(rearOffset, sideOffset);
                addWheelMark(frontOffset, -sideOffset);
                addWheelMark(frontOffset, sideOffset);
            }

            const kmh = Math.round(speed * 2.6);
            speedText.textContent = kmh.toString();
            driftText.textContent = Math.round(driftStrength * 100);

            // Drift-Score Berechnung
            let driftGain = 0;
            if (driftStrength > 0.15 && speed > 5) {
                driftGain = driftStrength * speed * dt * 4;

                if (isInDriftZone(car.x, car.y)) {
                    driftGain *= 1.4;
                }
                if (inRiskZone(car.x, car.y)) {
                    driftGain *= 2.0;
                }
                if (inOil(car.x, car.y)) {
                    driftGain *= 1.3;
                }

                driftGain *= comboMultiplier;

                driftScore += driftGain;
                totalXP += driftGain * 0.6;
            }

            driftScoreText.textContent = Math.round(driftScore).toString();
            updateLevelAndPreset();

            const inZone = isInDriftZone(car.x, car.y) && isOnTrack(car.x, car.y);
            driftZoneLabel.style.display = inZone ? "block" : "none";

            if (!isOnTrack(car.x, car.y)) {
                triggerAutoRespawn();
            }
        }

        // =========================
        // Rendering Helper
        // =========================
        function worldToScreen(wx, wy, camX, camY) {
            return {
                x: canvas.width / 2 + (wx - camX),
                y: canvas.height / 2 + (wy - camY)
            };
        }

        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawWheel(cx, cy, w, h) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.fillRect(-w / 2, -h / 2, w, h);
            ctx.restore();
        }

        // =========================
        // Track / Zonen zeichnen
        // =========================
        function drawTrack(camX, camY) {
            const cx = TRACK.cx;
            const cy = TRACK.cy;
            const w = TRACK.halfWidth * 2;
            const h = TRACK.halfHeight * 2;

            const screen = worldToScreen(cx, cy, camX, camY);

            ctx.save();
            ctx.translate(screen.x, screen.y);

            // Asphalt
            ctx.fillStyle = "#2b2f38";
            roundedRect(ctx, -w / 2, -h / 2, w, h, 40);
            ctx.fill();

            // AuÃŸenlinie
            ctx.lineWidth = 14;
            ctx.strokeStyle = "#f5f5f5";
            ctx.stroke();

            // Sand-Zonen
            for (const z of sandZones) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = "#a68c4f";
                const zx = z.x - cx;
                const zy = z.y - cy;
                ctx.fillRect(zx, zy, z.w, z.h);
                ctx.restore();
            }

            // Oil Spots
            for (const z of oilSpots) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                const zx = z.x - cx;
                const zy = z.y - cy;
                const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, z.radius);
                grad.addColorStop(0, "rgba(40,40,40,0.95)");
                grad.addColorStop(1, "rgba(10,10,10,0.0)");
                ctx.translate(zx, zy);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Drift-Zonen (Bonus-Felder)
            for (const z of driftZones) {
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = "#6a4dff";
                const zx = z.x - cx;
                const zy = z.y - cy;
                ctx.fillRect(zx, zy, z.w, z.h);
                ctx.restore();

                ctx.save();
                ctx.strokeStyle = "rgba(180,160,255,0.7)";
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 6]);
                ctx.strokeRect(zx, zy, z.w, z.h);
                ctx.restore();
            }

            // Risk-Zonen (Rand)
            for (const z of riskZones) {
                ctx.save();
                const zx = z.x - cx;
                const zy = z.y - cy;
                ctx.strokeStyle = "rgba(255,80,80,0.8)";
                ctx.setLineDash([6, 6]);
                ctx.lineWidth = 3;
                ctx.strokeRect(zx, zy, z.w, z.h);
                ctx.restore();
            }

            // Curbs innen
            const innerMargin = 22;
            const curbW = w - innerMargin * 2;
            const curbH = h - innerMargin * 2;
            const segmentsPerSide = 22;
            ctx.lineWidth = 10;

            function drawCurbSide(x1, y1, x2, y2, invert) {
                for (let i = 0; i < segmentsPerSide; i++) {
                    const t0 = i / segmentsPerSide;
                    const t1 = (i + 1) / segmentsPerSide;
                    const sx0 = x1 + (x2 - x1) * t0;
                    const sy0 = y1 + (y2 - y1) * t0;
                    const sx1 = x1 + (x2 - x1) * t1;
                    const sy1 = y1 + (y2 - y1) * t1;

                    ctx.strokeStyle = ((i + (invert ? 1 : 0)) % 2 === 0) ? "#ff5555" : "#f5f5f5";
                    ctx.beginPath();
                    ctx.moveTo(sx0, sy0);
                    ctx.lineTo(sx1, sy1);
                    ctx.stroke();
                }
            }

            drawCurbSide(-curbW / 2, -curbH / 2, curbW / 2, -curbH / 2, false);
            drawCurbSide(curbW / 2, -curbH / 2, curbW / 2, curbH / 2, true);
            drawCurbSide(curbW / 2, curbH / 2, -curbW / 2, curbH / 2, false);
            drawCurbSide(-curbW / 2, curbH / 2, -curbW / 2, -curbH / 2, true);

            // Mittellinien
            ctx.strokeStyle = "rgba(255,255,255,0.35)";
            ctx.lineWidth = 3;
            ctx.setLineDash([16, 18]);

            ctx.beginPath();
            ctx.moveTo(0, -h / 2 + 40);
            ctx.lineTo(0, h / 2 - 40);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-w / 2 + 40, 0);
            ctx.lineTo(w / 2 - 40, 0);
            ctx.stroke();

            ctx.setLineDash([]);
            ctx.restore();
        }

        function drawObstacles(camX, camY) {
            for (const o of obstacles) {
                const p = worldToScreen(o.x, o.y, camX, camY);
                ctx.save();
                ctx.translate(p.x, p.y);

                // Schatten
                ctx.fillStyle = "rgba(0,0,0,0.45)";
                ctx.beginPath();
                ctx.ellipse(0, 6, o.radius * 0.9, o.radius * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Kegel
                const h = o.radius * 1.7;
                const r = o.radius * 0.7;

                const grad = ctx.createLinearGradient(0, -h, 0, 0);
                grad.addColorStop(0, "#ffd08a");
                grad.addColorStop(0.4, "#ff8f2a");
                grad.addColorStop(1, "#b34500");

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(0, -h);
                ctx.lineTo(r, 0);
                ctx.lineTo(-r, 0);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = "rgba(255,255,255,0.9)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-r * 0.8, -h * 0.45);
                ctx.lineTo(r * 0.8, -h * 0.45);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-r * 0.6, -h * 0.2);
                ctx.lineTo(r * 0.6, -h * 0.2);
                ctx.stroke();

                ctx.restore();
            }
        }

        function drawPickups(camX, camY) {
            for (const p of pickups) {
                const s = worldToScreen(p.x, p.y, camX, camY);
                ctx.save();
                ctx.translate(s.x, s.y);

                const rad = p.radius;
                const grad = ctx.createRadialGradient(0, 0, 4, 0, 0, rad + 10);
                grad.addColorStop(0, "rgba(255,255,180,0.9)");
                grad.addColorStop(0.4, "rgba(255,230,120,0.7)");
                grad.addColorStop(1, "rgba(255,200,80,0.0)");
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, rad + 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = "#ffe76a";
                ctx.beginPath();
                ctx.arc(0, 0, rad * 0.7, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = "#ffcf40";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, rad * 0.5, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        // =========================
        // Minimap
        // =========================
        function drawMinimap() {
            const miniSize = 200;
            const padding = 16;
            const x0 = canvas.width - miniSize - padding;
            const y0 = padding;

            const wWorld = MAP_BOUNDS.maxX - MAP_BOUNDS.minX;
            const hWorld = MAP_BOUNDS.maxY - MAP_BOUNDS.minY;

            ctx.save();
            ctx.translate(x0, y0);

            ctx.fillStyle = "rgba(0,0,0,0.75)";
            ctx.fillRect(0, 0, miniSize, miniSize);

            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, miniSize, miniSize);

            function worldToMini(wx, wy) {
                const dx = (wx - MAP_BOUNDS.minX) / wWorld;
                const dy = (wy - MAP_BOUNDS.minY) / hWorld;
                return {
                    x: dx * miniSize,
                    y: dy * miniSize
                };
            }

            const p1 = worldToMini(TRACK.cx - TRACK.halfWidth, TRACK.cy - TRACK.halfHeight);
            const p2 = worldToMini(TRACK.cx + TRACK.halfWidth, TRACK.cy + TRACK.halfHeight);

            ctx.fillStyle = "#2b2f38";
            ctx.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);

            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1.5;
            ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);

            // Drift Zonen
            for (const z of driftZones) {
                const a = worldToMini(z.x, z.y);
                const b = worldToMini(z.x + z.w, z.y + z.h);
                ctx.fillStyle = "rgba(140,120,255,0.4)";
                ctx.fillRect(a.x, a.y, b.x - a.x, b.y - a.y);
                ctx.strokeStyle = "rgba(200,190,255,0.9)";
                ctx.lineWidth = 1;
                ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);
            }

            // Oil
            for (const z of oilSpots) {
                const mp = worldToMini(z.x, z.y);
                ctx.fillStyle = "#444";
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Sand
            for (const z of sandZones) {
                const a = worldToMini(z.x, z.y);
                const b = worldToMini(z.x + z.w, z.y + z.h);
                ctx.fillStyle = "rgba(180,150,80,0.5)";
                ctx.fillRect(a.x, a.y, b.x - a.x, b.y - a.y);
            }

            // Hindernisse
            for (const o of obstacles) {
                const mp = worldToMini(o.x, o.y);
                ctx.fillStyle = "#ff9d3b";
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Pickups
            for (const p of pickups) {
                const mp = worldToMini(p.x, p.y);
                ctx.fillStyle = "#ffe76a";
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Auto
            const carMini = worldToMini(car.x, car.y);
            ctx.save();
            ctx.translate(carMini.x, carMini.y);
            ctx.rotate(car.angle);
            ctx.fillStyle = "#ff4444";
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(4, 4);
            ctx.lineTo(-4, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            ctx.fillStyle = "#ffffff";
            ctx.font = "10px Arial";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText("MINIMAP", 6, 4);

            ctx.restore();
        }

        // =========================
        // Game Loop
        // =========================
        let last = performance.now();
        function loop(now) {
            const dt = (now - last) / 1000;
            last = now;

            updateRespawn(dt);
            updateCar(dt);
            updateSkidmarks(dt);
            updateChallenge(dt);

            const camX = car.x;
            const camY = car.y;

            // Hintergrund
            ctx.fillStyle = "#133018";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Struktur
            ctx.save();
            ctx.globalAlpha = 0.18;
            const sz = 240;
            for (let x = -3000; x <= 3000; x += sz) {
                for (let y = -3000; y <= 3000; y += sz) {
                    const screenPos = worldToScreen(x, y, camX, camY);
                    if (
                        screenPos.x + sz < 0 || screenPos.x - sz > canvas.width ||
                        screenPos.y + sz < 0 || screenPos.y - sz > canvas.height
                    ) continue;

                    ctx.fillStyle = ((x / sz + y / sz) % 2 === 0) ? "#1c2028" : "#181c24";
                    ctx.fillRect(screenPos.x, screenPos.y, sz, sz);
                }
            }
            ctx.restore();

            drawTrack(camX, camY);
            drawObstacles(camX, camY);
            drawPickups(camX, camY);

            // Skidmarks (dÃ¼nne Reifenspuren)
            for (const s of skidmarks) {
                const pos = worldToScreen(s.x, s.y, camX, camY);
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(s.angle);
                ctx.globalAlpha = Math.max(s.alpha * (s.life / 2.0), 0);
                ctx.fillStyle = "#000";
                ctx.fillRect(-1, -6, 2, 12);
                ctx.restore();
            }

            // Auto
            const carScreen = worldToScreen(car.x, car.y, camX, camY);

            if (respawn.visible) {
                ctx.save();
                ctx.translate(carScreen.x, carScreen.y);
                ctx.rotate(car.angle);

                const preset = carPresets[currentPresetIndex];

                // Schatten
                ctx.save();
                ctx.translate(4, 6);
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                roundedRect(ctx, -car.width / 2, -car.length / 2, car.width, car.length, 10);
                ctx.fill();
                ctx.restore();

                // Karosserie
                const bodyGradient = ctx.createLinearGradient(0, -car.length / 2, 0, car.length / 2);
                bodyGradient.addColorStop(0, "#20252f");
                bodyGradient.addColorStop(0.5, "#11141b");
                bodyGradient.addColorStop(1, "#20252f");
                ctx.fillStyle = bodyGradient;
                roundedRect(ctx, -car.width / 2, -car.length / 2, car.width, car.length, 10);
                ctx.fill();

                // Dach
                ctx.fillStyle = "#151921";
                roundedRect(ctx, -car.width * 0.35, -car.length * 0.15, car.width * 0.7, car.length * 0.5, 8);
                ctx.fill();

                // Scheiben
                ctx.fillStyle = "rgba(40,50,70,0.9)";
                roundedRect(ctx, -car.width * 0.32, -car.length * 0.3, car.width * 0.64, car.length * 0.18, 6);
                ctx.fill();
                roundedRect(ctx, -car.width * 0.32, car.length * 0.05, car.width * 0.64, car.length * 0.18, 6);
                ctx.fill();

                // Motorhaube & Heck in Preset-Farbe
                ctx.fillStyle = preset.colorMain;
                roundedRect(ctx, -car.width * 0.45, -car.length * 0.5, car.width * 0.9, car.length * 0.23, 8);
                ctx.fill();
                ctx.fillStyle = preset.colorAccent;
                roundedRect(ctx, -car.width * 0.45, car.length * 0.27, car.width * 0.9, car.length * 0.2, 8);
                ctx.fill();

                // Scheinwerfer
                ctx.fillStyle = "#ffe9b0";
                ctx.fillRect(-car.width * 0.4, -car.length * 0.5 - 1, car.width * 0.3, 4);
                ctx.fillRect(car.width * 0.1, -car.length * 0.5 - 1, car.width * 0.3, 4);

                // RÃ¼cklichter
                ctx.fillStyle = "#ff4040";
                ctx.fillRect(-car.width * 0.4, car.length * 0.5 - 4, car.width * 0.3, 4);
                ctx.fillRect(car.width * 0.1, car.length * 0.5 - 4, car.width * 0.3, 4);

                // RÃ¤der
                ctx.fillStyle = "#111";
                drawWheel(-car.width / 2 + 6, -car.length / 2 + 18, 8, 4);
                drawWheel(car.width / 2 - 6, -car.length / 2 + 18, 8, 4);
                drawWheel(-car.width / 2 + 6, car.length / 2 - 18, 8, 4);
                drawWheel(car.width / 2 - 6, car.length / 2 - 18, 8, 4);

                // Lichtkegel
                ctx.save();
                ctx.globalAlpha = 0.35;

                function headlightCone(offsetX) {
                    const frontY = -car.length * 0.5;
                    const innerY = frontY - 4;
                    const outerY = frontY - car.length * 1.5;
                    const spread = car.width * 0.8;

                    const grad = ctx.createLinearGradient(
                        offsetX, innerY,
                        offsetX, outerY
                    );
                    grad.addColorStop(0, "rgba(255, 233, 176, 0.9)");
                    grad.addColorStop(1, "rgba(255, 233, 176, 0.0)");
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.moveTo(offsetX - 4, innerY);
                    ctx.lineTo(offsetX + 4, innerY);
                    ctx.lineTo(offsetX + spread, outerY);
                    ctx.lineTo(offsetX - spread, outerY);
                    ctx.closePath();
                    ctx.fill();
                }

                headlightCone(-car.width * 0.25);
                headlightCone(car.width * 0.25);

                ctx.restore(); // Licht
                ctx.restore(); // Auto
            }

            drawMinimap();

            // Challenge-Status im HUD
            challengeStatusEl.textContent = "Status: " + (challengeRunning ? "LÃ¤uft..." : challengeResult);

            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);
    </script>
</body>
</html>

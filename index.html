<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>2D Drift City</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
            font-family: Arial, sans-serif;
            color: #fff;
            user-select: none;
        }

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            border-left: 4px solid #ff4747;
            font-size: 14px;
        }

        #hud-title {
            font-weight: 900;
            letter-spacing: 1px;
            font-size: 18px;
            margin-bottom: 4px;
            color: #ffd54a;
        }

        #controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            text-align: right;
            font-size: 12px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div id="hud-title">2D DRIFT CITY</div>
        <div>Speed: <span id="speedText">0</span> km/h</div>
        <div>Drift: <span id="driftText">0</span>%</div>
    </div>

    <div id="controls">
        W / S – Gas / Bremse<br>
        A / D – Lenken<br>
        SPACE – Handbremse / mehr Drift<br>
        R – Reset
    </div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const speedText = document.getElementById('speedText');
        const driftText = document.getElementById('driftText');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // =========================
        // Steuerung
        // =========================
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false
        };

        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = true;
            if (k === ' ') keys.space = true;
            if (k === 'r') resetCar();
        });

        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (k in keys) keys[k] = false;
            if (k === ' ') keys.space = false;
        });

        // =========================
        // Welt / Track
        // =========================
        const world = {
            width: 3000,
            height: 2000
        };

        // einfache Track-Daten (Dekolinien, Gebäude)
        const trackLines = [];
        const buildings = [];

        function createTrack() {
            // Straße als breites Band schlangenförmig
            // wir benutzen nur Deko-Linien, physikalisch ist überall "Straße"
            for (let x = -400; x <= 400; x += 40) {
                trackLines.push({ x, y: -600, w: 20, h: 1200, rot: 0 });
            }

            // ein paar Kurven / Querabschnitte
            for (let z = -300; z <= 300; z += 40) {
                trackLines.push({ x: -300, y: z, w: 20, h: 600, rot: 0 });
                trackLines.push({ x: 300, y: z, w: 20, h: 600, rot: 0 });
            }

            // Gebäude als rechteckige Blöcke (nur Optik, keine Kollision)
            buildings.push({ x: -650, y: -300, w: 300, h: 500 });
            buildings.push({ x: 650, y: -200, w: 280, h: 400 });
            buildings.push({ x: -650, y: 400, w: 260, h: 300 });
            buildings.push({ x: 650, y: 350, w: 260, h: 300 });

            // zentraler Platz / Kreuzung
            buildings.push({ x: 0, y: -800, w: 500, h: 200 });
        }

        createTrack();

        // =========================
        // Car-Physik (Topdown, Drift)
        // =========================

        const car = {
            x: 0,
            y: 0,
            angle: 0,          // Heading
            vx: 0,
            vy: 0,
            width: 40,
            length: 80,
            maxSpeed: 40,      // "physikalische" Einheiten, später in km/h umgerechnet
            acceleration: 60,
            brake: 80,
            friction: 2.5,
            grip: 10,          // je niedriger, desto mehr Drift
            handbrakeGrip: 4,
            steering: 2.0,     // Lenkwinkel pro Sekunde (in Grad)
        };

        function resetCar() {
            car.x = 0;
            car.y = 0;
            car.angle = -Math.PI / 2; // nach oben
            car.vx = 0;
            car.vy = 0;
        }

        resetCar();

        const skidmarks = [];

        function updateCar(dt) {
            // Richtung als Unit-Vector
            const cos = Math.cos(car.angle);
            const sin = Math.sin(car.angle);

            // Vorwärts-/Rückwärts-Geschwindigkeit (Projektionskomponenten)
            const forwardSpeed = car.vx * cos + car.vy * sin;
            const sideSpeed = -car.vx * sin + car.vy * cos;

            let accel = 0;

            if (keys.w) accel += car.acceleration;
            if (keys.s) accel -= car.brake;

            // Beschleunigung in Fahrtrichtung
            const newForwardSpeed = forwardSpeed + accel * dt;
            let limitedForward = newForwardSpeed;

            const maxFwd = car.maxSpeed;
            const maxBack = -car.maxSpeed * 0.5;

            if (limitedForward > maxFwd) limitedForward = maxFwd;
            if (limitedForward < maxBack) limitedForward = maxBack;

            // Grip: seitliche Geschwindigkeit stark bremsen -> Drift entsteht wenn sideSpeed groß ist
            let grip = keys.space ? car.handbrakeGrip : car.grip;
            const newSideSpeed = sideSpeed * Math.exp(-grip * dt);

            // zurück in Welt-Geschwindigkeit
            car.vx = limitedForward * cos - newSideSpeed * sin;
            car.vy = limitedForward * sin + newSideSpeed * cos;

            // globale Reibung
            const speed = Math.hypot(car.vx, car.vy);
            if (speed > 0) {
                const frictionForce = car.friction * dt;
                const newSpeed = Math.max(speed - frictionForce, 0);
                const scale = newSpeed / speed;
                car.vx *= scale;
                car.vy *= scale;
            }

            // Lenken proportional zur Fahrtgeschwindigkeit
            const steerInput = (keys.a ? 1 : 0) + (keys.d ? -1 : 0); // links positiv
            if (steerInput !== 0 && speed > 0.5) {
                const steerAmount = (car.steering * Math.PI / 180) * steerInput * dt * (speed / car.maxSpeed);
                car.angle += steerAmount;
            }

            // Position aktualisieren
            car.x += car.vx * dt;
            car.y += car.vy * dt;

            // "sanfte" Begrenzung des Spielfeldes, damit man nicht komplett verschwindet
            const margin = 900;
            if (car.x < -world.width / 2 - margin) car.x = -world.width / 2 - margin;
            if (car.x > world.width / 2 + margin) car.x = world.width / 2 + margin;
            if (car.y < -world.height / 2 - margin) car.y = -world.height / 2 - margin;
            if (car.y > world.height / 2 + margin) car.y = world.height / 2 + margin;

            // Skidmarks: wenn SideSpeed groß genug ist
            const driftStrength = Math.min(Math.abs(sideSpeed) / 20, 1); // 0..1
            if (driftStrength > 0.25 && speed > 5) {
                const rearOffset = -car.length * 0.4;
                const wx = car.x + rearOffset * cos;
                const wy = car.y + rearOffset * sin;
                skidmarks.push({
                    x: wx,
                    y: wy,
                    alpha: 0.6 + 0.4 * driftStrength,
                    life: 2.0
                });
            }

            // HUD updaten
            const kmh = Math.round(speed * 3); // Skala tweak
            speedText.textContent = kmh.toString();
            driftText.textContent = Math.round(driftStrength * 100);
        }

        function updateSkidmarks(dt) {
            for (let i = skidmarks.length - 1; i >= 0; i--) {
                skidmarks[i].life -= dt;
                if (skidmarks[i].life <= 0) {
                    skidmarks.splice(i, 1);
                }
            }
        }

        // =========================
        // Rendering
        // =========================

        function worldToScreen(wx, wy, camX, camY) {
            return {
                x: canvas.width / 2 + (wx - camX),
                y: canvas.height / 2 + (wy - camY)
            };
        }

        function draw(dt) {
            // Kamera folgt dem Auto
            const camX = car.x;
            const camY = car.y;

            // Hintergrund
            ctx.fillStyle = "#15181f";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // leichte "City-Farbfelder" im Hintergrund
            ctx.save();
            ctx.globalAlpha = 0.18;
            const sz = 200;
            for (let x = -2000; x <= 2000; x += sz) {
                for (let y = -2000; y <= 2000; y += sz) {
                    const screenPos = worldToScreen(x, y, camX, camY);
                    if (
                        screenPos.x + sz < 0 || screenPos.x - sz > canvas.width ||
                        screenPos.y + sz < 0 || screenPos.y - sz > canvas.height
                    ) continue;

                    ctx.fillStyle = ((x / sz + y / sz) % 2 === 0) ? "#1c2028" : "#181c24";
                    ctx.fillRect(screenPos.x, screenPos.y, sz, sz);
                }
            }
            ctx.restore();

            // Skidmarks
            for (const s of skidmarks) {
                const screen = worldToScreen(s.x, s.y, camX, camY);
                ctx.save();
                ctx.globalAlpha = Math.max(s.alpha * (s.life / 2.0), 0);
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.ellipse(screen.x, screen.y, 6, 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Track-Linien
            ctx.save();
            ctx.globalAlpha = 0.8;
            for (const t of trackLines) {
                const screen = worldToScreen(t.x, t.y, camX, camY);
                if (
                    screen.x + t.h < -100 || screen.x - t.h > canvas.width + 100 ||
                    screen.y + t.h < -100 || screen.y - t.h > canvas.height + 100
                ) continue;

                ctx.save();
                ctx.translate(screen.x, screen.y);
                ctx.rotate(t.rot);
                ctx.fillStyle = "#3c414b";
                ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);
                ctx.restore();
            }
            ctx.restore();

            // Buildings
            ctx.save();
            for (const b of buildings) {
                const screen = worldToScreen(b.x, b.y, camX, camY);
                if (
                    screen.x + b.w < -100 || screen.x - b.w > canvas.width + 100 ||
                    screen.y + b.h < -100 || screen.y - b.h > canvas.height + 100
                ) continue;

                ctx.fillStyle = "#222831";
                ctx.fillRect(screen.x - b.w / 2, screen.y - b.h / 2, b.w, b.h);

                ctx.fillStyle = "#11141a";
                ctx.fillRect(screen.x - b.w / 2, screen.y - b.h / 2, b.w, 10);
            }
            ctx.restore();

            // Auto zeichnen (CLS-Topdown-Style)
            const carScreen = worldToScreen(car.x, car.y, camX, camY);
            ctx.save();
            ctx.translate(carScreen.x, carScreen.y);
            ctx.rotate(car.angle);

            // Schatten
            ctx.save();
            ctx.translate(4, 6);
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            roundedRect(ctx, -car.width / 2, -car.length / 2, car.width, car.length, 10);
            ctx.fill();
            ctx.restore();

            // Karosserie
            const bodyGradient = ctx.createLinearGradient(-car.width / 2, 0, car.width / 2, 0);
            bodyGradient.addColorStop(0, "#20252f");
            bodyGradient.addColorStop(0.5, "#11141b");
            bodyGradient.addColorStop(1, "#20252f");
            ctx.fillStyle = bodyGradient;
            roundedRect(ctx, -car.width / 2, -car.length / 2, car.width, car.length, 10);
            ctx.fill();

            // Dach
            ctx.fillStyle = "#151921";
            roundedRect(ctx, -car.width * 0.35, -car.length * 0.15, car.width * 0.7, car.length * 0.5, 8);
            ctx.fill();

            // Scheiben
            ctx.fillStyle = "rgba(40,50,70,0.9)";
            roundedRect(ctx, -car.width * 0.32, -car.length * 0.3, car.width * 0.64, car.length * 0.18, 6);
            ctx.fill();
            roundedRect(ctx, -car.width * 0.32, car.length * 0.05, car.width * 0.64, car.length * 0.18, 6);
            ctx.fill();

            // Motorhaube & Heck farblich wie CLS
            ctx.fillStyle = "#c00000";
            roundedRect(ctx, -car.width * 0.45, -car.length * 0.5, car.width * 0.9, car.length * 0.23, 8);
            ctx.fill();
            ctx.fillStyle = "#8c0000";
            roundedRect(ctx, -car.width * 0.45, car.length * 0.27, car.width * 0.9, car.length * 0.2, 8);
            ctx.fill();

            // Lichter
            ctx.fillStyle = "#ffe9b0";
            ctx.fillRect(-car.width * 0.4, -car.length * 0.5 - 1, car.width * 0.3, 4);
            ctx.fillRect(car.width * 0.1, -car.length * 0.5 - 1, car.width * 0.3, 4);

            // Rücklichter
            ctx.fillStyle = "#ff4040";
            ctx.fillRect(-car.width * 0.4, car.length * 0.5 - 4, car.width * 0.3, 4);
            ctx.fillRect(car.width * 0.1, car.length * 0.5 - 4, car.width * 0.3, 4);

            // Felgen / Räder
            ctx.fillStyle = "#111";
            drawWheel(-car.width / 2 + 6, -car.length / 2 + 18, 8, 4);
            drawWheel(car.width / 2 - 6, -car.length / 2 + 18, 8, 4);
            drawWheel(-car.width / 2 + 6, car.length / 2 - 18, 8, 4);
            drawWheel(car.width / 2 - 6, car.length / 2 - 18, 8, 4);

            ctx.restore();
        }

        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawWheel(cx, cy, w, h) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.fillRect(-w / 2, -h / 2, w, h);
            ctx.restore();
        }

        // =========================
        // Game Loop
        // =========================

        let last = performance.now();
        function loop(now) {
            const dt = (now - last) / 1000;
            last = now;

            updateCar(dt);
            updateSkidmarks(dt);
            draw(dt);

            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);
    </script>
</body>
</html>

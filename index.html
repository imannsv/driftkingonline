<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Drift King Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #111;
            font-family: system-ui, sans-serif;
        }

        #overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="overlay">
        <b>Drift King Online</b><br>
        W / S = Gas / Bremse<br>
        A / D = Lenken<br>
        Space = Handbremse (Drift)
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
        window.onload = () => {

            // === Szene / Kamera / Renderer ===
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x9ad9ff);
            scene.fog = new THREE.Fog(0x9ad9ff, 70, 220);

            const camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 6, -12);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // === Licht ===
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(30, 60, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024);
            scene.add(sun);

            // === Boden & Arena ===
            const groundGeo = new THREE.PlaneGeometry(300, 300);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x6b7684,
                roughness: 1,
                metalness: 0,
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const arenaGeo = new THREE.PlaneGeometry(90, 140);
            const arenaMat = new THREE.MeshStandardMaterial({
                color: 0x252935,
                roughness: 1,
                metalness: 0,
                flatShading: true
            });
            const arena = new THREE.Mesh(arenaGeo, arenaMat);
            arena.rotation.x = -Math.PI / 2;
            arena.position.y = 0.02;
            scene.add(arena);

            function createLine(width, height, x, z) {
                const geo = new THREE.PlaneGeometry(width, height);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 1,
                    metalness: 0,
                    flatShading: true,
                    side: THREE.DoubleSide
                });
                const line = new THREE.Mesh(geo, mat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.03, z);
                scene.add(line);
            }

            // Rahmen & Mittellinie
            createLine(90, 1, 0, 70);
            createLine(90, 1, 0, -70);
            createLine(1, 140, 45, 0);
            createLine(1, 140, -45, 0);
            createLine(4, 30, 0, 0);

            // Anime-Häuser im Hintergrund
            const colors = [0xff9aa2, 0xffe29f, 0xbaffc9, 0xa0c4ff, 0xd4b5ff];
            const blockGeo = new THREE.BoxGeometry(10, 12, 10);
            for (let i = 0; i < 10; i++) {
                const mat = new THREE.MeshStandardMaterial({
                    color: colors[i % colors.length],
                    roughness: 1,
                    flatShading: true
                });
                const block = new THREE.Mesh(blockGeo, mat);
                block.castShadow = true;
                block.receiveShadow = true;
                const side = Math.random() > 0.5 ? 1 : -1;
                block.position.set(
                    side * (60 + Math.random() * 40),
                    6,
                    (Math.random() - 0.5) * 180
                );
                scene.add(block);
            }

            // === Auto-Gruppe (CLS-Style) ===
            const car = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x111111,            // fast schwarz
                roughness: 0.9,             // matt
                metalness: 0.2,
                flatShading: true
            });

            // Hauptrumpf – lange Limousine
            const mainBody = new THREE.Mesh(
                new THREE.BoxGeometry(2.6, 0.7, 5.2),
                bodyMat
            );
            mainBody.castShadow = true;
            mainBody.position.y = 0.75;
            car.add(mainBody);

            // Motorhaube
            const hood = new THREE.Mesh(
                new THREE.BoxGeometry(2.4, 0.55, 1.6),
                bodyMat
            );
            hood.position.set(0, 0.7, 1.7);
            hood.castShadow = true;
            car.add(hood);

            // Heckbereich (leicht höher)
            const rear = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.65, 1.6),
                bodyMat
            );
            rear.position.set(0, 0.8, -1.9);
            rear.castShadow = true;
            car.add(rear);

            // Dach / Coupé-Linie
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.7, 2.6),
                new THREE.MeshStandardMaterial({
                    color: 0x151515,
                    roughness: 0.9,
                    metalness: 0.2,
                    flatShading: true
                })
            );
            roof.position.set(0, 1.25, -0.2);
            roof.castShadow = true;
            car.add(roof);

            // Scheiben (leicht blau)
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x93b7ff,
                roughness: 0.2,
                metalness: 0,
                flatShading: true
            });

            const sideGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.15, 0.55, 2.3),
                glassMat
            );
            sideGlass.position.set(0, 1.25, -0.2);
            car.add(sideGlass);

            // Heckscheibe
            const rearGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.0, 0.5, 0.1),
                glassMat
            );
            rearGlass.position.set(0, 1.1, -2.0);
            car.add(rearGlass);

            // Frontscheibe
            const frontGlass = new THREE.Mesh(
                new THREE.BoxGeometry(2.0, 0.6, 0.1),
                glassMat
            );
            frontGlass.position.set(0, 1.15, 1.2);
            car.add(frontGlass);

            // Frontlippe / AMG Stoßstange
            const frontBumper = new THREE.Mesh(
                new THREE.BoxGeometry(2.8, 0.4, 0.8),
                new THREE.MeshStandardMaterial({
                    color: 0x050505,
                    roughness: 1,
                    flatShading: true
                })
            );
            frontBumper.position.set(0, 0.45, 2.6);
            car.add(frontBumper);

            // Heckdiffusor
            const rearDiff = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.35, 0.9),
                new THREE.MeshStandardMaterial({
                    color: 0x050505,
                    roughness: 1,
                    flatShading: true
                })
            );
            rearDiff.position.set(0, 0.45, -2.7);
            car.add(rearDiff);

            // kleiner Spoiler auf der Kante
            const spoiler = new THREE.Mesh(
                new THREE.BoxGeometry(2.3, 0.1, 0.4),
                bodyMat
            );
            spoiler.position.set(0, 0.95, -2.7);
            car.add(spoiler);

            // Rückleuchten (CLS-Style)
            function addTaillight(x, z) {
                const tl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 0.25, 0.1),
                    new THREE.MeshStandardMaterial({
                        color: 0xff4b5c,
                        emissive: 0xff1b3c,
                        emissiveIntensity: 0.7,
                        flatShading: true
                    })
                );
                tl.position.set(x, 0.85, z);
                car.add(tl);
            }
            addTaillight(-1.0, -2.4);
            addTaillight(1.0, -2.4);

            // Scheinwerfer vorn
            function addHeadlight(x, z) {
                const hl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.25, 0.2),
                    new THREE.MeshStandardMaterial({
                        color: 0xfff7c2,
                        emissive: 0xfff0a0,
                        emissiveIntensity: 0.8,
                        flatShading: true
                    })
                );
                hl.position.set(x, 0.6, z);
                car.add(hl);
            }
            addHeadlight(-0.9, 2.6);
            addHeadlight(0.9, 2.6);

            // Auspuffblenden
            function addExhaust(x, z) {
                const ex = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.15, 0.2),
                    new THREE.MeshStandardMaterial({
                        color: 0x999999,
                        roughness: 0.3,
                        metalness: 0.8,
                        flatShading: true
                    })
                );
                ex.position.set(x, 0.35, z);
                car.add(ex);
            }
            addExhaust(-0.8, -3.0);
            addExhaust(0.8, -3.0);

            // Räder (goldene Felgen)
            const tireMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 1,
                metalness: 0.2,
                flatShading: true
            });

            const rimMat = new THREE.MeshStandardMaterial({
                color: 0xd4af37, // Gold
                roughness: 0.4,
                metalness: 1,
                flatShading: true
            });

            const wheelGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.5, 14);

            function addWheel(x, z) {
                const wheelGroup = new THREE.Group();

                const tire = new THREE.Mesh(wheelGeo, tireMat);
                tire.rotation.z = Math.PI / 2;
                tire.castShadow = true;
                wheelGroup.add(tire);

                const rim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.45, 0.45, 0.51, 12),
                    rimMat
                );
                rim.rotation.z = Math.PI / 2;
                wheelGroup.add(rim);

                wheelGroup.position.set(x, 0.4, z);
                car.add(wheelGroup);
            }

            addWheel(-1.45, 1.8);
            addWheel(1.45, 1.8);
            addWheel(-1.45, -1.8);
            addWheel(1.45, -1.8);

            car.position.set(0, 0, 0);
            scene.add(car);

            // === Steuerung & Drift-Physik ===
            const keys = {};
            document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

            let velocity = new THREE.Vector3(0, 0, 0);
            let carAngle = 0;

            const accel = 0.09;
            const brake = 0.12;
            const maxSpeed = 2.5;
            const baseFriction = 0.96;
            const gripSideFriction = 0.92;    // mehr Grip
            const driftSideFriction = 0.985;  // leichter Drift
            const turnFactor = 0.08;

            function updateCar(delta) {
                const forward = keys['w'] || keys['arrowup'];
                const back = keys['s'] || keys['arrowdown'];
                const left = keys['a'] || keys['arrowleft'];
                const right = keys['d'] || keys['arrowright'];
                const handbrake = keys[' '];

                // Drehung des Autos als Quaternion
                const quat = new THREE.Quaternion();
                quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), carAngle);

                // Geschwindigkeit in Auto-Koordinaten
                const invQuat = quat.clone().invert();
                const localVel = velocity.clone().applyQuaternion(invQuat);

                const factor = delta * 60; // grobe Normalisierung

                // Gas / Bremse
                if (forward) localVel.z -= accel * factor;
                if (back) localVel.z += brake * factor * 0.7;

                // Speed begrenzen
                const speed = Math.abs(localVel.z);
                if (speed > maxSpeed) {
                    localVel.z = Math.sign(localVel.z) * maxSpeed;
                }

                // Lenken nur, wenn Speed da ist
                let steer = 0;
                if (left) steer += 1;
                if (right) steer -= 1;

                const steerStrength = Math.min(1, Math.abs(localVel.z) / (maxSpeed * 0.5));
                carAngle += steer * turnFactor * steerStrength;

                // Drift vs. Grip
                const sideFriction = handbrake ? driftSideFriction : gripSideFriction;
                localVel.x *= sideFriction;
                localVel.z *= baseFriction;

                // zurück in Weltkoordinaten
                velocity.copy(localVel).applyQuaternion(quat);

                // Position updaten
                car.position.add(velocity);
                car.position.y = 0;
                car.rotation.y = carAngle;
            }

            // === Chase-Cam ===
            const cameraTargetPos = new THREE.Vector3();
            function updateCamera(delta) {
                const offset = new THREE.Vector3(0, 4, 10);
                const quat = new THREE.Quaternion();
                quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), carAngle);
                const worldOffset = offset.applyQuaternion(quat);

                cameraTargetPos.copy(car.position).add(worldOffset);
                camera.position.lerp(cameraTargetPos, 0.08);
                camera.lookAt(
                    car.position.x,
                    car.position.y + 1.3,
                    car.position.z
                );
            }

            // === Loop ===
            let lastTime = performance.now();
            function animate(now) {
                requestAnimationFrame(animate);
                const delta = (now - lastTime) / 1000;
                lastTime = now;

                updateCar(delta);
                updateCamera(delta);

                renderer.render(scene, camera);
            }

            animate(lastTime);

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        }; // window.onload
    </script>
</body>
</html>
